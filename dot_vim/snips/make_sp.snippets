# vim: fdm=marker tw=99 et
global !p
# Check if we are in a multiline-grading-comment.
def m():
    return (snip.buffer[snip.line].startswith('# ')
            and re.match(r'^##K\s*\^?$', snip.buffer[snip.line - 1]))  # ##K ^
endglobal

# These snippets must include the '#' at the start of each line, as make does not support multiline
# comments.
# TODO Is there a better way to handle the '#' in the first line? :/
# General {{{
context "m()"
snippet all "all nicht erstes Target"
"all" muss das erste Target im Makefile sein (mit Ausnahme von ".PHONY"), da ein Aufruf von
# "make" in der Kommandozeile standardmaessig das erste Target erstellt. (-0.5)
endsnippet

context "m()"
snippet clean_.o "clean loescht nicht alle Zwischenprodukte"
Das "clean"-Target muss auch alle Zwischenprodukte (d.h. alle erzeugten .o-Dateien) loeschen.
# (-0.5)
endsnippet

context "m()"
snippet dependency "Abhaengigkeit fehlt"
Abhaengigkeit fuer "${1:header.h}" fehlt. (-0.5)
endsnippet

context "m()"
snippet dollar^ "$^"
Hier kann man auch "$^" verwenden, was zu allen Abhaengigkeiten expandiert. Dann spart man sich
# das Abtippen, und kann dort keine Leichtsinnsfehler mehr machen. ;)
endsnippet

context "m()"
snippet dollar@ "$@"
Hier kann man auch "$@" verwenden, was zum Namen des Targets expandiert. Das spart ein bisschen
# Tipparbeit. ;)
endsnippet

context "m()"
snippet flags "Compilerflags fehlen"
Beim Compilen muessen die Compileroptionen, die auf der Webseite angegeben sind, genutzt werden.
# (-0.5)
endsnippet

context "m()"
snippet pattern "keine Pattern-Regeln"
Hier sollen (so weit moeglich) Pattern-Regeln verwendet werden, z.B. fuer "%.o: %.c". (-1.0)
endsnippet

context "m()"
snippet phony ".PHONY fehlt"
Pseudo-Targets (= erzeugen keine Datei mit dem Namen des Targets) muessen als Abhaengigkeit des
# Spezial-Targets ".PHONY" angegeben werden, damit diese immer gebaut werden. In SP betrifft
# das die Targets "all" und "clean". (-0.5)
endsnippet

context "m()"
snippet rm_-f "-f fehlt bei rm"
Beim Aufruf von "rm" sollte die Option "-f" verwendet werden. Das sorgt dafuer, dass kein Fehler
# auftritt, wenn eine der angegebenen Dateien nicht existiert (z.B. weil mehrmals hintereinander
# "make clean" aufgerufen wird).
endsnippet

context "m()"
snippet rm_multiple "mehrfache rm-Aufrufe"
rm(1) nimmt auch mehrere Argumente in einem Aufruf entgegen. ;)
endsnippet

context "m()"
snippet var_name "Variable anders benannt"
Das nennt man per Konvention eigentlich "${1:CFLAGS}". ;)
endsnippet

context "m()"
snippet var_use "Variable nicht verwendet"
Normal packt man ${1:das hier} in eine Variable, damit man das nicht mehrmals tippen (bzw.
# copy-pasten) muss. ;)
endsnippet
# }}}

# The jbuffer-function for the "context" is found in the C-snippets.
# jbuffer {{{
context "m() and jbuffer()"
snippet jbuffer_header_dep_for_lib "Header ist Abhaengigkeit fuer Library"
Die Header braucht es hier nicht mehr als Abhaengigkeit, da die Informationen ja schon in der
# .o-Datei stecken. Dementsprechend hast du die Header auch als Abhaengigkeit bei den jeweiligen
# .o-Dateien (und dadurch ist dann letztendlich auch die Library von den Headern abhaengig, da die
# Abhaengigkeiten ja rekursiv aufgeloest werden - dafuer muessen die Header nicht nochmal extra
# angegeben werden).
endsnippet

context "m() and jbuffer()"
snippet jbuffer_L_missing "-L. fehlt beim Linken"
Hier muss noch angegeben werden, in welchem Pfad nach der Library (die mit "-l${1:jbuffer}"
# angegeben ist) gesucht werden soll. Dafuer braucht man das "-L" gefolgt vom Pfad; da die Library
# im aktuellen Ordner liegt, funktioniert also einfach "-L.". (-0.5)
endsnippet

context "m() and jbuffer()"
snippet jbuffer_object_dep_for_test "Objekt-Datei ist Abhaengigkeit fuer Test"
Die Objekt-Dateien braucht man hier nicht als Abhaengigkeiten, da die Informationen ja schon in
# der Bilbiothek stecken; man braucht die Abhaengigkeiten also nur beim Erzeugen der Bibliothek.
endsnippet

context "m() and jbuffer()"
snippet jbuffer_pic_missing "dynamische Bibliothek nicht PIC"
"Die beiden Module der dynamischen Bibliothek (und nur diese) sollen als Position-Independent
# Code uebersetzt werden": man muss hier also noch extra .o-Dateien erzeugen, welche mit "-fPIC"
# kompiliert wurden. (-1.0)
endsnippet

context "m() and jbuffer()"
snippet jbuffer_pic_unneeded "PIC unnoetigerweise verwendet"
Nachdem dieses Modul nicht Teil der Bibliothek ist, muss es auch nicht positionsunabhaengig sein.
# Das war auch in der Aufgabenstellung so gefordert: "Die beiden Module der dynamischen Bibliothek
# (und nur diese) sollen als Position-Independent Code uebersetzt werden". (-0.5)
endsnippet
# }}}
