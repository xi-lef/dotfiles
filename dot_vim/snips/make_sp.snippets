# vim: fdm=marker tw=99 et
# These snippets must include the '#' at the start of each line, as make does not support multiline
# comments.
# TODO how to handle # in first line? :/
global !p
# TODO doc
def m():
    return (re.match('^##K\s*\^?$', snip.buffer[snip.line - 1])
            and snip.buffer[snip.line].startswith('# '))
            #and re.match('^#\s', snip.buffer[snip.line]))
def jbuffer(): return 'jbuffer' in snip.buffer.name
endglobal

# General {{{
context "m()"
snippet "all" "all nicht erstes Target"
"all" muss das erste Target im Makefile sein (mit Ausnahme von ".PHONY"), da ein Aufruf von
# "make" in der Kommandozeile standardmaessig das erste Target erstellt. (-0.5)
endsnippet

context "m()"
snippet "clean .o" "clean loescht nicht alle Zwischenprodukte"
Das "clean"-Target muss auch alle Zwischenprodukte (d.h. alle erzeugten .o-Dateien) loeschen.
# (-0.5)
endsnippet

context "m()"
snippet "dependency" "Abhaengigkeit fehlt"
Abhaengigkeit fuer "${1:header.h}" fehlt. (-0.5)
endsnippet

context "m()"
snippet "dollar^" "$^"
Hier kann man auch "$^" verwenden, was zu allen Abhaengigkeiten expandiert. Dann spart man sich
# das Abtippen, und kann dort keine Leichtsinnsfehler mehr machen. ;)
endsnippet

context "m()"
snippet "dollar@" "$@"
Hier kann man auch "$@" verwenden, was zum Namen des Targets expandiert. Das spart ein bisschen
# Tipparbeit. ;)
endsnippet

context "m()"
snippet "flags" "Compilerflags fehlen"
Beim Compilen muessen die Compileroptionen, die auf der Webseite angegeben sind, genutzt werden.
# (-0.5)
endsnippet

context "m()"
snippet "pattern" "keine Pattern-Regeln"
Hier sollen (so weit moeglich) Pattern-Regeln verwendet werden, z.B. fuer "%.o: %.c". (-1.0)
endsnippet

context "m()"
snippet "phony" ".PHONY fehlt"
Pseudo-Targets (= erzeugen keine Datei mit dem Namen des Targets) muessen als Abhaengigkeit des
# Spezial-Targets ".PHONY" angegeben werden, damit diese immer gebaut werden. In SP betrifft
# das die Targets "all" und "clean". (-0.5)
endsnippet

context "m()"
snippet "rm -f" "-f fehlt bei rm"
Beim Aufruf von "rm" sollte die Option "-f" verwendet werden. Das sorgt dafuer, dass kein Fehler
# auftritt, wenn eine der angegebenen Dateien nicht existiert (z.B. weil mehrmals hintereinander
# "make clean" aufgerufen wird).
endsnippet

context "m()"
snippet "rm multiple" "mehrfache rm-Aufrufe"
rm(1) nimmt auch mehrere Argumente in einem Aufruf entgegen. ;)
endsnippet
# }}}

# jbuffer {{{
# }}}
