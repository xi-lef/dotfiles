# vim: fdm=marker tw=99 et
# Global {{{
global !p
re_start = r'^/\*K\s*\^?$'  # /*K ^
re_end = r'^\*/$'  # */

# Check if we are in a multiline-grading-comment.
def c():
    for l in reversed(snip.buffer[: snip.line]):
        if re.match(re_end, l):
            return False
        elif re.match(re_start, l):
            return True
    return False

# Used for task-specific snippets.
def in_task(name: str):
    return name in snip.buffer.name

def lilo(): return in_task('lilo')
def wsort(): return in_task('wsort')
def halde(): return in_task('halde')
def clash(): return in_task('clash')
def mach(): return in_task('mach')
def creeper(): return in_task('creeper')
def snail(): return in_task('snail')
def sister(): return in_task('sister')
def rush(): return in_task('rush')
def jbuffer(): return in_task('jbuffer')
def mother(): return in_task('mother')

# Get the name of the variable that the '^' at the start of the current grading-comment points to.
# The '^' can point to any character that is part of the variable; it does not need to be precise.
def var():
    w = vim.current.window
    y = w.cursor[0] - 1

    y_arrow = next(i for i, l in reversed(list(enumerate(w.buffer[: y])))
                                 if re.match(re_start, l))
    x_arrow = w.buffer[y_arrow].find('^')
    if x_arrow == -1: return 'var'

    # Search for the first invalid character to the left of the '^' to find the beginning of the
    # variable name.
    l = w.buffer[y_arrow - 1]
    m = re.search(r'\W', l[x_arrow :: -1])
    offset = 0 if not m else (m.start(0) - 1)

    m = re.search(r'\w+', l[x_arrow - offset :])
    if not m: return 'var'
    return m[0]
endglobal
# }}}

# General {{{
context "c()"
snippet atoi "atoi() statt strtol()"
atoi(3) darf nicht  verwendt werden, da man damit keine Fehler abfangen kann: es kann z.B. nicht
unterschieden werden, ob die Eingabe eine 0 war, oder ein Fehler aufgetreten ist. Stattdessen muss
strtol(3) verwendet werden (siehe auch Korrekturhinweise auf der Webseite). (-2.0)
endsnippet

context "c()"
snippet char_array_sizeof "kein sizeof() fuer char-Array"
Da "${1:arr}" als char-Array definiert ist, kann man hier "sizeof($1)" verwenden. Dadurch muss die
Groesse nicht explizit doppelt angegeben werden, und es koennen nicht versehentlich
unterschiedliche Werte genutzt werden. ;)
endsnippet

context "c()"
snippet closedir "closedir() fehlt"
Das muss mit closedir(3) wieder geschlossen werden. (-1.0)
endsnippet

context "c()"
snippet debug_output "Debug-Ausgaben enthalten"
Solche Debug-Ausgaben bitte vor der Abgabe entfernen, so was gehoert nicht in ein fertiges Programm
(was die Abgabe darstellen sollte ;)).${1: (-0.5)}
endsnippet

context "c()"
snippet errno_overwritten "errno durch Funktionsaufruf ueberschrieben"
Durch diesen Funktionsaufruf wird potentiell die errno ueberschrieben, wodurch das perror(3)
danach eine falsche Fehlermeldung ausgeben koennte.${1: (-0.5)}
endsnippet

context "c()"
snippet errno_no_perror "kein perror() trotz gesetzter errno"
In diesem Fall ist die errno gesetzt (durch ${1:func(3)}), weswegen hier perror(3) verwendet
werden sollte, um eine passende Fehlermeldung auszugeben. Als Argument fuer perror(3) uebergibt man
dann einfach den Namen der fehlgeschlagenen Funktion, also hier "perror("${1/([^(]+).*/$1/}")".
endsnippet

context "c()"
snippet errno_undefined "errno im (potentiellen) Erfolgsfall verwendet"
Wenn eine Bibliotheksfunktion erfolgreich war, ist der Wert der errno undefiniert (siehe auch
Manpage errno(3)). Hier darf also nicht der Wert der errno zur Fehlerbehandlung verwendet werden;
stattdessen muss der Rueckgabewert von "${1:func(3)}" genutzt werden. (-0.5)
endsnippet

context "c()"
snippet error_handling "Fehlerbehandlung fehlt"
Fehlerbehandlung fehlt. (-${1|1.0,0.5,1.5,2.0|})
endsnippet

context "c()"
snippet fclose "fclose() fehlt"
Das muss mit fclose(3) wieder geschlossen werden. (-1.0)
endsnippet

context "c()"
snippet ferror_feof "ferror()/feof() fehlt"
Fuer eine korrekte Fehlerbehandlung muss hier noch ferror(3) oder feof(3) betrachtet werden, um zu
wissen, ob ein Fehler aufgetreten ist, oder lediglich EOF erreicht wurde. (-0.5)
endsnippet

context "c()"
snippet fflush "fflush() fehlt"
Hier muss noch ein fflush(3) samt Fehlerbehandlung stehen, um sicherzugehen, dass die Ausgabe
auch wirklich rausgeschrieben wird. Sonst kann es sein, dass die Ausgabe bis jetzt nur in einem
Puffer gespeichert, aber noch nicht tatsaechlich rausgeschrieben wurde. (-1.5)
endsnippet

context "c()"
snippet fgetc "[f]getc() char als return type"
[f]getc returnt einen "int", d.h. das muss auch in einem "int" gespeichert werden, damit die
Fehlerbehandlung (konkret: der Vergleich mit "EOF") korrekt funktionieren kann. (-1.0)
endsnippet

context "c()"
snippet format_string_attack "Format-String Angriff moeglich"
Das ist problematisch, da "${1:`!p snip.rv = var()`}" ein String vom Benutzer ist, aber von printf
als Format-String interpretiert wird. Wenn der Benutzer hier also z.B. ein "%d" reinschreibt, wird
das, was als naechstes auf dem Stack liegt, als Dezimalzahl ausgegeben. In solchen Faellen muss
deswegen immer "%s" als Format-String verwendet werden. (-1.0)
endsnippet

context "c()"
snippet free "free() fehlt"
Das muss mit free(3) wieder freigegeben werden. (-1.0)
endsnippet

context "c()"
snippet free_in_error_case "Ressourcen im Fehlerfall freigegeben"
Im Fehlerfall muessen keine Ressourcen freigegeben werden, wenn das Programm im Rahmen der
Fehlerbehandlung beendet wird. Dadurch kann der Code etwas uebersichtlicher bleiben. ;)
endsnippet

context "c()"
snippet freeaddrinfo "freeaddrinfo() fehlt"
Das muss mit freeaddrinfo(3) wieder freigegeben werden. (-1.0)
endsnippet

context "c()"
snippet global "unnoetig globale Variable"
Diese Variable ist unnoetig global und koennte genauso gut eine lokale Variable in "${1:func}"
sein. (-0.5)
endsnippet

context "c()"
snippet malloc_instead_of_stack "malloc() statt Stack-Allokation"
Das haette man auch auf dem Stack machen koennen. Das spart die Fehlerbehandlung und das free(3)
spaeter, was deutlich angenehmer zu schreiben ist. ;)
endsnippet

context "c()"
snippet nullbyte "Platz fuer '\0' fehlt"
Hier fehlt ein Byte fuer das '\0'. (-0.5)
endsnippet

context "c()"
snippet perror_no_errno "perror() trotz ungesetzter errno"
In diesem Fall ist die errno nicht gesetzt, deswegen kann hier perror(3) nicht verwendet werden.
Man muss hier mit fprintf(3) selbst eine aussagekraeftige Fehlermeldung schreiben.
endsnippet

context "c()"
snippet pthread_id_array "Thread-ID unnoetigerweise gespeichert"
Da die Thread-IDs spaeter nicht mehr verwendet werden (z.B. fuer ein pthread_join(3)), ist es
unnoetig, hier alle IDs in einem Array abzuspeichern. ;)
endsnippet

context "c()"
snippet readdir_errno "errno vor readdir() nicht auf 0 gesetzt"
Die errno muss vor jedem readdir(3)-Aufruf auf 0 gesetzt werden. Sonst ist es nicht moeglich,
zwischen einem Fehler und end-of-directory-stream zu unterscheiden (siehe auch Manpage). (-0.5)
endsnippet

context "c()"
snippet semdestroy "semDestroy() fehlt"
Das muss mit semDestroy() wieder freigegeben werden. (-1.0)
endsnippet

context "c()"
snippet sizeof_char "sizeof(char) statt 1"
"sizeof(char)" ist in C immer 1; man kann sich das also sparen. ;)
endsnippet

context "c()"
snippet static "Hilfsfunktion/-variable nicht static"
Hilfsfunktionen/-variablen muessen static sein, damit diese nicht fuer andere Module sichtbar sind.
(-${1|0.5,1.0|})
endsnippet

context "c()"
snippet stderr "Fehlerausgaben auf stdout"
Fehlermeldungen gehoeren auf stderr. Das geht am einfachsten mit fprintf(3). (-0.5)
endsnippet

context "c()"
snippet strtol_endptr "endptr bei strtol() nicht verwendet"
Hier muss "endptr" verwendet werden, um zwei Fehler abpruefen zu koennen: erstens kann der String
leer sein, in welchem Fall einfach 0 returnt wird. Zweitens koennen nach der eigentlich Zahl noch
Buchstaben enthalten sein (z.B. "123a"), was ja auch nicht sein soll. Siehe auch Manpage strtol(3).
(-0.5)
endsnippet

context "c()"
snippet unused "unverwendete Variable/Funktion"
"`!p snip.rv = var()`" wird im restlichen Code nie verwendet.
endsnippet

context "c()"
snippet variables_c89 "alle Variablen am Anfang deklariert"
Es gibt keinen Grund, alle Variablen am Anfang zu deklarieren. Wenn sie erst kurz vor der
Verwendung deklariert werden, ist das deutlich uebersichtlicher. :)
endsnippet
# }}}

# SP1 {{{

# lilo {{{
context "c() and lilo()"
snippet lilo_access_freed_memory "Zugriff auf bereits freigegebenen Speicher"
Der Speicherbereich, auf den der Zeiger "${1:`!p snip.rv = var()`}" zeigt, ist zu diesem Zeitpunkt
bereits freigegeben. Der Zugriff auf einen freigegebenen Speicherbereich ist undefiniertes
Verhalten; "$1" darf also erst danach freigegeben werden. Hier muss der zurueckzugebende Wert
demnach in einer Variable zwischengespeichert werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_error_message_output "Fehlerausgabe gemacht"
Laut Aufgabenstellung sollen keine Fehlermeldung ausgegeben werden: die Funktionen "insertElement"
und "removeElement" koennen als Bibliotheksfunktionen angesehen werden. Bei solchen Funktionen soll
der Aufrufer entscheiden, ob er eine Fehlermeldung ausgeben will, oder nicht. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_error_handling "Fehlerbehandlung fehlt"
Fehlerbehandlung fehlt. Wenn Funktionen (wie z.B. malloc(3)) mit einem Fehler zurueckkehren, dieser
aber nicht behandelt wird, fuehrt dies zum Programmabsturz. Deshalb muss man immer
Fehlerueberpruefungen durchfuehren, und auftretende Fehler entsprechend behandeln. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_first_element_unchecked "erstes Element nicht auf Gleichheit geprueft"
Das erste Element der Liste wird hier nicht mit dem einzufuegenden Wert verglichen, wodurch
womoeglich Werte doppelt eingefuegt werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_free_insert "free() fehlt in insertElement-Fehlerfall"
Wenn das bereits angelegte Listenelement gar nicht in die Liste eingefuegt wird, wird es spaeter
auch nie aus dieser entfernt. Der mit malloc(3) allokierte Speicher wird in diesem Fall also nicht
freigegeben: hier liegt ein Speicherleck vor. (-1.0)
endsnippet

context "c() and lilo()"
snippet lilo_free_remove "free() fehlt in removeElement"
Der Speicher, der vom entfernten Listenelement belegt wurde, muss noch freigegeben werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_last_element_unchecked "letztes Element nicht auf Gleichheit geprueft"
Das letzte Element der Liste wird hier nicht mit dem einzufuegenden Wert verglichen, wodurch
womoeglich Werte doppelt eingefuegt werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_negative_values "negative Werte erlaubt"
Laut Aufgabenstellung soll die Funktion "insertElement" nur *nicht*-negative Werte in die Liste
einfuegen. Hier fehlt die entsprechende Pruefung. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_static_head "static (bei Head) vergessen"
Hier fehlt das Keyword "static": die Verwendung von globalen Variablen sollte vermieden werden
(siehe Vorlesung A II 7.5). Da in diesem Fall eine Variable mit erweiterter Sichtbarkeit und
Lebensdauer notwendig ist, muss eine modulglobale Variable verwendet werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_uninitialized_values "uninitialisierte Werte durch malloc()"
Der Speicher fuer das Listenelement wurde mit malloc(3) angelegt und ist damit uninitialisiert
(d.h. es stehen zufaellige Werte im Speicher). Daher ist es notwendig, alle Strukturkomponenten zu
initialisieren; alternativ kann auch direkt calloc(3) verwendet werden, welches mit den Speicher
mit nullen initialisiert. (-0.5).
endsnippet

context "c() and lilo()"
snippet lilo_unneeded_global "unnoetig globale Variable"
Diese Variable ist unnoetigerweise global, allerdings sollte die Verwendung von globalen Variablen
vermieden werden (siehe Vorlesung A II 7.5). In diesem Fall reicht eine lokale Variable aus. (-0.5)
endsnippet
# }}}

# wsort {{{
context "c() and wsort()"
snippet wsort_102 "Puffer fuer Zeilen zu klein"
Laut Aufgabenstellung ist ein Wort maximal 100 Zeichen lang. Damit wird ein Puffer der Groesse 102
benoetigt, da zusaetzlich zum eigentlichen Wort noch ein '\n' (das laut Aufgabenstellung nicht zum
Wort gehoert) sowie ein '\0' dazu kommen. (-1)
endsnippet

context "c() and wsort()"
snippet wsort_compare_pointer "Pointer in compare() inkorrekt verwendet"
Diese Funktion wird von qsort(3) aufgerufen, und bekommt dabei *Pointer* auf die zu sortierenden
Elemente uebergeben. Diese Elemente sind hier Strings, also "char *"; diese Funktion bekommt also
Pointer auf Strings, also "char **" uebergeben. Hier werden nun die Pointer sortiert, es muessen
aber die Strings "dahinter" sortiert werden. Dafuer muessen die Argumente korrekt gecasted werden,
bevor sie verwendet werden. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_empty_lines "leere Zeilen nicht ignoriert"
Laut Aufgabenstellung sollen leere Zeilen ignoriert werden. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_fgets_size "falsche size bei fgets()"
fgets(3) muss hier die Groesse des uebergebenen Puffers ("${1:buf}") uebergeben werden; das
beinhaltet also auch den Platz fuer das '\0'.${2: Da hier "$1" ein char-Array ist, kann auch direkt
"sizeof($1)" verwendet werden - dann kann dieser Fehler gar nicht passieren.} (-0.5)
endsnippet

context "c() and wsort()"
snippet wsort_fgets_err "Fehlerbehandlung fgets() fehlt"
Fehlerbehandlung fuer fgets(3) fehlt: sobald fgets(3) NULL zurueckgibt muss noch geprueft werden,
ob ein Fehler aufgetreten ist. Dafuer gibt es dann feof(3) bzw. ferror(3) (siehe auch
Korrekturhinweise auf der Webseite). (-1.5)
endsnippet

context "c() and wsort()"
snippet wsort_LF_last_line "letzte Zeile ohne '\n' falsch behandelt"
Laut Aufgabenstellung muss die letzte Zeile nicht zwangslaeufig ein '\n' enthalten - das geht hier
kaputt, da ${1:...}
endsnippet

context "c() and wsort()"
snippet wsort_LF_not_removed "\n ist Teil des Wortes"
Laut Aufgabenstellung ist das '\n' am Ende einer Zeile nicht Teil des Wortes. Hier werden diese nie
entfernt und dadurch mitsortiert, was zu einer falschen Sortierreihenfolge fuehrt. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_overlong_condition "unerfuellbare Bedingung zur Erkennung von ueberlangen Zeilen"
Diese Bedingung kann nie erfuellt sein, da fgets(3) nur ${1:101} Zeichen (exklusive '\0') einliest.
strlen(3) gibt die Laenge des Strings (also die Anzahl an Zeichen vor dem '\0') zurueck, was
niemals groesser sein kann. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_overlong_missing "Behandlung von ueberlangen Zeilen fehlt"
Hier fehlt ${1:das Erkennen (-3.0) sowie }das Ignorieren (-2.0) von ueberlangen Zeilen.
endsnippet

context "c() and wsort()"
snippet wsort_static "static (bei Hilfsfunktion) vergessen"
Hier fehlt "static". Alle Schnittstellen, die nicht in der Aufgabenstellung verlangt sind, sollen
nach aussen hin nicht sichtbar sein. Ohne das "static" ist es anderen Modulen (mit denen dieses
Modul womoeglich zusammen gelinkt wird) erlaubt, ebenfalls diese Funktion zu verwenden. Das
verhindert einen erfolgreichen Link-Vorgang. (-0.5)
endsnippet
# }}}

# halde {{{
context "c() and halde()"
snippet halde_free_magic "free: MAGIC nicht geprueft"
Fuer "${1:`!p snip.rv = var()`}" muss noch geprueft werden, ob im dazugehoerigen "mblock->next"
wirklich "MAGIC" steht. Dazu soll sichergestellt werden, dass der uebergebene Pointer wirklich von
"malloc" kommt, und nicht einfach ein zufaelliger Pointer uebergeben wurde. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_function_local_static "keine funktionslokale static Variable"
Eine *funktionslokale* static Variable waere hier schoener, da das ja nur in "malloc" verwendet
wird. ;)
endsnippet

context "c() and halde()"
snippet halde_realloc_size "realloc: zu viel kopiert"
Hier duerfen maximal "min(size, mblock->size)" viele Bytes kopiert werden, da sonst ueber den
verwalteten Speicherplatz hinausgeschrieben wird, wobei die Daten in anderen mblocks ueberschrieben
werden koennten. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_size_modified "malloc: size faelschlicherweise verkleinert"
Die Groesse des vergebenen mblocks darf nur veraendert (also verkleinert) werden, wenn ein neuer
mblock dahinter angelegt wird. Sonst geht der Speicher, der vom vergebenen mblock nicht verwendet
wird, dauerhaft verloren. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_test_edge_case "test: kein Randfall abgeprueft"
Laut Aufgabenstellung soll mindestens einer der in der Manpage beschriebenen Randfaelle abgeprueft
werden. (-0.5) Ideal waere sogar, alle Randfaelle abzupruefen. ;)
endsnippet
# }}}

# clash {{{
context "c() and clash()"
snippet clash_cd_exit "exit() bei cd"
Das ist ein Fall, wo es sinnvoll ist, das exit(3) wegzulassen: wenn man sich einfach nur beim
Pfadnamen vertippt, will man ja nicht, dass sich die ganze Shell beendet. ;)
endsnippet

context "c() and clash()"
snippet clash_fflush "fflush() beim Prompt fehlt"
Hier fehlt ein fflush(3), da sonst die Ausgabe nicht sicher auf das Terminal geschrieben wird, da
stdout standardmaessig zeilenweise gepuffert ist. Da nach dem Prompt (korrekterweise) kein '\n'
geschrieben wird, ist also ein fflush(3) noetig. (-0.5)
endsnippet

context "c() and clash()"
snippet clash_getcwd_err "Fehlerbehandlung getcwd() fehlt"
Fehlerbehandlung fuer getcwd() mit Vergroesserung des Puffers fehlt. (-3.0)
endsnippet

context "c() and clash()"
snippet clash_getcwd_errno "errno im getcwd()-Fehlerfall nicht geprueft"
Der Puffer darf hier nur vergroessert werden, wenn die errno "ERANGE" lautet, da ja auch andere
Fehler auftreten koennen, als dass der Puffer zu klein war (siehe Manpage). In anderen Faellen
braucht man noch eine normale Fehlerbehandlung. (-1.0)
endsnippet

context "c() and clash()"
snippet clash_getcwd_path_max "PATH_MAX fuer getcwd() verwendet"
"PATH_MAX" zu verwenden ist hier nicht korrekt: es muss das in der Manpage von getcwd(3)
beschriebene Vorgehen verwendet werden. Im Internet gibt es viele Erklaerungen, warum "PATH_MAX"
quasi nie verwendet werden sollte; eine gute und kompakte Erklaerung gibt es auch in der Manpage
von der aehnlichen Funktion realpath(3) in der Sektion 'BUGS'. (-2.0)
endsnippet

context "c() and clash()"
snippet clash_overlong "ueberlange Zeilen nicht ignoriert"
Zu lange Zeilen muessen hier noch erkannt und mit einer Warnung verworfen werden (wie auch in der
wsort). (-3.0)
endsnippet

context "c() and clash()"
snippet clash_plist_walklist "walkList: kein fruehzeitiges Abbrechen des Durchlaufens"
Hier fehlt die Beachtung der Abbruchbedingung, wenn "callback" 0 zurueckgibt (siehe plist.h).
Selbst wenn das in clash.c nie verwendet wird, muss das hier implementiert werden, da die plist
quasi als Bibliothek zu betrachten ist, und andere Nutzer der plist dieses Feature vielleicht
verwenden wollen. (-0.5)
endsnippet

context "c() and clash()"
snippet clash_wexitstatus_wifexited "WEXITSTATUS() ohne vorheriges WIFEXITED()"
"WEXITSTATUS" darf laut der Manpage nur verwendet werden, wenn "WIFEXITED" true zurueckgibt. (-1.0)
endsnippet

context "c() and clash()"
snippet clash_wexitstatus "kein WEXITSTATUS() verwendet"
Das hier ist nicht der Exitstatus, dort stehen auch noch andere Informationen drin. Um an den
eigentlichen Exitstatus zu kommen, muss das Makro "WEXITSTATUS" verwendet werden (siehe Manpage).
(-1.0)
endsnippet
# }}}

# mach {{{
context "c() and mach()"
snippet mach_buffer_overwrite "Puffer fuer Befehlszeile wird ueberschrieben"
Dieser Puffer wird von jedem fgets(3)-Aufruf wiederverwendet, d.h. der Pufferinhalt wird bei jedem
Schleifendurchlauf ueberschrieben. Da dieser Puffer dann direkt an den Arbeiterthread uebergeben
wird, verwenden letztendlich alle Arbeiterthreads den selben Puffer, was natuerlich nicht
funktionieren kann. Jeder Arbeiterthread braucht seinen eigenen Puffer, was am leichtesten mit
strdup(3) erreicht werden kann. (-1.0)
endsnippet

context "c() and mach()"
snippet mach_detach_worker "Arbeiterthreads nicht detached"
Die Arbeiterthreads sollen mittels pthread_detach(3) detached werden, damit die Ressourcen beim
Beenden automatisch freigegeben werden. (-1.0)
endsnippet

context "c() and mach()"
snippet mach_join_detached_thread "pthread_join() auf detached Thread"
Wenn ein Thread mittels pthread_detach(3) detached wurde, kann auf diesen nicht mehr mit
pthread_join(3) gewartet werden. Hier braucht man Semaphoren zum Warten. (-1.0)
endsnippet

context "c() and mach()"
snippet mach_output_thread_join "nicht auf Ausgabethread gewartet"
Es muss noch gewartet werden, bis der Ausgabethread sich beendet hat, damit sicher alle Ausgaben
rausgeschrieben werden. Das geht am leichtesten mit pthread_join(3). (-1.0)
endsnippet

context "c() and mach()"
snippet mach_slow_critical "langsame Funktion in kritischem Abschnitt"
Langsame Funktionen (wie ${1:`!p snip.rv = var()`(3)}) duerfen laut Aufgabenstellung nicht in
kritischen Abschnitten ausgefuehrt werden. (-1.0)
endsnippet
# }}}

# creeper {{{
context "c() and creeper()"
snippet creeper_basename "basename() auf Original-String"
basename(3) kann den Inhalt des uebergebenen Strings veraendern. Daher muss man eine Kopie anlegen,
wenn man den Inhalt danach nochmal benutzen will. (-1.0)
endsnippet

context "c() and creeper()"
snippet creeper_dir_assumption "Annahme, dass etwas ein Verzeichnis ist"
Man darf nicht davon ausgehen, dass das hier ein Verzeichnis ist, da auf der Kommandozeile auch
regulaere Dateien uebergeben werden duerfen. Man muss also zuerst pruefen, um was fuer eine Art von
Verzeichniseintrag es sich hierbei handelt. (-1.0)
endsnippet

context "c() and creeper()"
snippet creeper_exit "exit() in Rekursion"
Hier zu sterben ist keine gute Idee, da Fehler wie z.B. "EACCES" (fehlende Berechtigung) haeufiger
auftreten werden. Stattdessen einfach mit dem naechsten Verzeichniseintrag weiterzumachen ist
besser. (-0.5)
endsnippet

context "c() and creeper()"
snippet creeper_fnm_period "kein FNM_PERIOD"
Die Pruefung soll gemaess Shell-Wildcards erfolgen. Damit fuehrende Punkte in "${1:pattern}"
explizit angegeben werden muessen (so wie es bei Shell-Wildcards ist, siehe Manpage glob(7)), muss
"FNM_PERIOD" in den Flags enthalten sein. (-0.5)
endsnippet

context "c() and creeper()"
snippet creeper_lstat_stat "stat() statt lstat() verwendet"
Hier muss lstat(2) verwendet werden, da laut Aufgabenstellung symbolische Links ignoriert werden
sollen. Um das zu erreichen, muss man bei einem symbolischen Link Informationen ueber den Link
selbst bekommen, und nicht ueber das, worauf der Link verweist. Das geht nur mit lstat(2), da
stat(2) den symbolischen Link quasi dereferenziert (siehe Manpage). (-1.0)
endsnippet

context "c() and creeper()"
snippet creeper_skip_dot ". und .. nicht uebersprungen"
Die Verzeichniseintraege "." und ".." muessen uebersprungen werden, da es sonst zu einer
Endlosrekursion kommt. (-1.0)
endsnippet
# }}}

# }}}

# SP2 {{{

# snail {{{
context "c() and snail()"
snippet snail_ai_addrconfig "kein AI_ADDRCONFIG in Flags"
Wenn in "ai_flags" das "AI_ADDRCONFIG" fehlt, kann es passieren, dass im späteren Verlauf eine
Verbindungsart gewählt wird, die weder vom Kernel noch der Hardware unterstützt wird; der Fehler
wird erst beim Aufruf von socket(2) geschehen. Da eine entsprechende Fehlermeldung den Nutzer nur
unnötig verunsichert, ist es hier angebracht, mit AI_ADDRCONFIG nach unterstützten Verbindungen zu
filtern.
endsnippet

context "c() and snail()"
snippet snail_doubled_CR "doppeltes \r bei Benutzereingabe"
Die Eingabe kann bereits ein '\r' enthalten (je nach Benutzersystem). In diesem Fall wird hier
faelschlicherweise ein zusaetzliches '\r' eingefuegt. (-0.5)
endsnippet

context "c() and snail()"
snippet snail_expected_status_code "erwarteter Status-Code als int"
Wenn man den erwarteten Status-Code direkt als String uebergibt, spart man sich die Umwandlung
zwischen String und Zahl. Dann kann man den eingelesenen Status-Code direkt mittels strcmp(3)
vergleichen. ;)
endsnippet

context "c() and snail()"
snippet snail_gethostname_length "namelen bei gethostname() anders als bei Definition"
Hier muss der gleiche Wert verwendet werden wie oben bei der Definition von "${1:hostname}". (-0.5)
endsnippet

context "c() and snail()"
snippet snail_getpwuid
Es ist nicht erlaubt, in den von getpwuid(3) zurückgegebenen Speicher zu schreiben. Stattdessen
muss eine Kopie der Daten angelegt werden, wenn diese verändert werden sollen.
"The application shall not modify the structure to which the return value points, nor any storage
areas pointed to by pointers within the structure." (Manpage getpwuid(3p)) (-1.0)
endsnippet

context "c() and snail()"
snippet snail_last_answer "letzte Serverantwort nicht ausgegeben"
Im Fehlerfall soll die letzte Antwort des Servers (auf stderr) ausgegeben werden. (-1.0)
endsnippet

context "c() and snail()"
snippet snail_length_response "Annahme ueber Laenge der Antwort getroffen"
Es duerfen keine Annahmen ueber die maximale Laenge einer Antwortzeile, die vom Server kommt,
getroffen werden. Der einfachste Weg, mit solchen Zeilen unbekannter Laenge umzugehen, ist
ein zeichenweises Vorgehen, z.B. mit fgetc(3). (-2.0)
endsnippet

context "c() and snail()"
snippet snail_line_endings "Zeilen enden nicht auf \r\n"
Alle an den Server uebertragenen Zeilen muessen auf "\r\n" (DOS-Format) enden. (-1.0)
endsnippet

context "c() and snail()"
snippet snail_mailbody "Mail-Body am Anfang eingelesen"
Es ist ziemlich schade, wenn der Benutzer seine gesamte Mail eintippt, nur damit dann z.B. beim
Herstellen der Verbindung ein Fehler auftritt, der zum Programmabbruch fuehrt. Ein anderer Aufbau
waere hier schlauer gewesen.
endsnippet

context "c() and snail()"
snippet snail_socket_exit "exit() bei socket()"
In diesem Fall sollte das Programm nicht beendet werden. Der Punkt der for-Schleife ist ja, dass
verschiedene Moeglichkeiten (d.h. verschiedene Arten von Sockets) ausprobiert werden; wenn also
eine davon nicht funktioniert, soll hier einfach die naechste versucht werden. Nur wenn keine
einzige Moeglichkeit geklappt hat, muss das Programm tatsaechlich beendet werden, weil natuerlich
nicht sinnvoll weiter gemacht werden kann. (-1.0)
endsnippet
# }}}

# sister {{{
context "c() and sister()"
snippet sister_accept "exit() bei accept"
In diesem Fall sollte das Programm nicht beendet werden, nur weil die Verbindung nicht hergestellt
werden konnte. Der Server kann in dieser Situation durchaus weiter laufen, denn mindestens die
folgenden Fehler sind keine Schwerwiegenden und sollten ein Retry zur Folge haben:
"For reliable operation the application should detect the network errors defined for the protocol
after accept() and treat them like EAGAIN by retrying. In the case of TCP/IP, these are ENETDOWN,
EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH." (Manpage
accept(2))
Die Fehlermeldung kann ja trotzdem mit perror() ausgeben werden. (-0.5)
endsnippet

context "c() and sister()"
snippet sister_child_return "return im Kind"
Im Kind darf auf keinen Fall returnt werden: der Kind-Prozess muss sich mittels exit(3) beenden.
Sonst kehrt er in die accept(2)-Schleife in "main" zurueck, und man hat auf einmal mehrere
Prozesse, die auf dem gleichen Socket auf Anfragen warten. (-1.0)
endsnippet

context "c() and sister()"
snippet sister_fork "exit() bei fork()"
fork(2) kann auch aufgrund von Ressourcen-Knappheit scheitern, was im späteren Verlauf wieder
gelingen kann. Zum Beispiel kann es sein, dass gerade sehr viele Kinder existieren, und erst
gewartet werden muss, bis sich eins von ihnen beendet hat.
Deshalb sollte hier im Fehlerfall das Program nicht beendet werden. (-0.5)
endsnippet

context "c() and sister()"
snippet sister_clientSock_close "kein close() auf clientSock im Elternprozess"
Im Elternprozess muss noch "clientSock" geschlossen werden, da dieser beim fork(2) auch dupliziert
wurde (siehe auch Foliensatz zur rush, 3.5). Damit am Ende keine Ressourcen geleakt werden, muss er
hier geschlossen werden, sobald er nicht mehr gebraucht wird (was eigentlich sofort ist). (-0.5)
endsnippet

context "c() and sister()"
snippet sister_listenSock_close "kein close() auf listenSock im Kind"
Im Kind muss noch "listenSock" geschlossen werden, da dieser beim fork(2) auch dupliziert wurde
(siehe auch Foliensatz zur rush, 3.5). Das steht uebrigens auch in connection.h explizit drin. ;)
(-0.5)
endsnippet

context "c() and (sister() or mother())"
snippet sister_multiple_answers "mehrere http*()-Aufrufe"
Es wurde bereits eine Antwort mit "${1:httpOk}" gesendet. Hier nochmal eine (andere) Antwort zu
schicken ist schlecht, da der Browser das nicht erwartet und dementsprechend kaputt anzeigt. (-0.5)
endsnippet

context "c() and sister()"
snippet sister_regular_file "nicht auf regulaere Datei geprueft"
Es sollen lediglich regulaere Dateien ausgeliefert werden, wofuer man stat(2) verwenden muss.
(-1.0)
endsnippet

context "c() and sister()"
snippet sister_wwwpath "wwwpath Laenge nicht geprueft"
Es waere schoen, noch zu pruefen, ob der wwwpath ein leerer String ist, was dann mit einer
Fehlermeldung abgehandelt werden kann.
endsnippet
# }}}

# rush {{{
context "c() and rush()"
snippet rush_fork_sigchld_unblocked "SIGCHLD vor fork() nicht blockiert"
Vor dem fork(2) muss SIGCHLD blockiert werden. Falls sich der Kindprozess, der hier erzeugt wird,
beendet, bevor der Elternprozess diesen in die plist eintragen kann, wird hier naemlich ein SIGCHLD
zugestellt. Das geht dann im Signalhandler kaputt, da dort ja erwartet wird, dass der Kindprozess
in der plist steht. (-2.0)
endsnippet

context "c() and rush()"
snippet rush_kill_exit "exit() bei kill()"
Hier lieber nicht sterben, denn: "ESRCH  The process or process group does not exist. Note that an
existing process might be a zombie, a process that has terminated execution, but has not yet been
wait(2)ed for" (Manpage kill(2)). Und das ist moeglich, da hier SIGCHLD blockiert ist, und deswegen
der Kindprozess, der gerade getoetet werden soll, noch ein Zombie sein kann. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_kill_not-child "kill() moeglicherweise fuer nicht-Kindprozess"
Es muss noch geprueft werden, ob der zu toetende Prozess ueberhaupt ein eigener Kindprozess ist.
Dafuer muss man in der plist mittels "plistGet" nachschauen. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_nuke_plist_unsynchronized "ungeschuetzter Zugriff auf plist in nuke()"
Da hier auf der plist gearbeitet wird, muss SIGCHLD blockiert sein. Sonst kann es passieren, dass
die selbststaendige Terminierung eines zu toetenden Kindprozesses etwas kaputt macht, da in dem
Fall ja unsynchronisiert auf die plist zugegriffen werden wuerde. Auch kann es natuerlich
passieren, dass sich der Kindprozess beendet, und die PID wiederverwendet wird - dann wird ein
(vermutlich) komplett anderer Prozess faelschlicherweise getoetet. Es muss also bis nach dem
sleep(3) verhindert werden, dass SIGCHLD zugestellt wird. (-2.0)
endsnippet

context "c() and rush()"
snippet rush_open_flags "open() flags falsch"
Hier muessen die korrekten "flags" angegeben werden, oder einfacher: creat(2) genutzt werden.
(-0.5)
endsnippet

context "c() and rush()"
snippet rush_open_mode "open() mode falsch"
Laut Aufgabenstellung soll die erstellte Datei Leserechte fuer alle und Schreibrechte fuer den
Besitzer haben. Dafuer kann man eine Veroderung der in der Manpage angegeben Makros nutzen:
"S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH". (-0.5)
endsnippet

context "c() and rush()"
snippet rush_plist_unsynchronized_access "ungeschuetzter Zugriff auf plist"
Um hier auf der plist zu arbeiten, muss sichergestellt werden, dass der Signalhandler nicht
gleichzeitig auf die plist zugreift, da sonst der interne Zustand kaputt gehen kann. Um das zu
erreichen, muss hier voruebergehend die Zustellung von SIGCHLD blockiert werden. (-2.0)
endsnippet

context "c() and rush()"
snippet rush_redirection_close "close() fehlt bei Ein-/Ausgabeumleitung"
Der Dateideskriptor "${1:`!p snip.rv = var()`}" muss hier noch geschlossen werden. Nach dem dup2(2)
existieren erstmal zwei Dateideskriptoren, die auf die gleiche Datei zeigen ("$1" und
"STDIN_FILENO"); dementsprechend muss hier close(2) verwendet werden. (-1.0)
endsnippet

context "c() and rush()"
snippet rush_sa_mask "sa_mask nicht gesetzt bei SIGCHLD-Handler"
Hier muss noch der "sa_mask"-Member mittels sigemptyset(3) initialisiert werden. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_sa_restart "SA_RESTART fehlt bei Signalhandler"
Hier muss "SA_RESTART" in den Flags angegeben werden, damit Systemaufrufe, die von einem Signal
unterbrochen wurden, einfach neugestartet werden. Alternativ muessten bei allen Systemaufrufen der
Fehler "EINTR" entsprechend behandelt werden, was aber sehr viel komplizierter ist. ;) (-1.0)
endsnippet

context "c() and rush()"
snippet rush_signal_handler_errno "errno im Signalhandler nicht gesichert"
Im Signalhandler muss die errno(3) am Anfang gesichert und am Ende wiederhergestellt werden, wenn
sie durch den Signalhandler veraendert werden kann. In diesem Fall kann die errno von waitpid(2)
gesetzt werden. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_signal_handler_loop "keine Schleife im Signalhandler"
Wenn sich mehrere Kindprozesse gleichzeitig beenden, wird zwar prinzipiell auch mehrmals das
SIGCHLD zugestellt, aber es wird nur einmal zwischengespeichert - d.h. der Signalhandler wird auch
nur einmal aufgerufen. Das liegt daran, dass die Signale gleichzeitig kommen koennen, und der
Elternprozess dann nicht mit dem Behandeln "hinterherkommt". Deswegen muss man im Signalhandler
davon ausgehen, dass man nicht ein einzelnes Signal behandelt, sondern zwischen null und
"unendlich" viele: man braucht hier also eine Schleife, um waitpid(2) wiederholt auszufuehren.
(-1.0)
endsnippet

context "c() and rush()"
snippet rush_signal_handler_stdio "Ausgaben im Signalhandler mit stdio"
In einem Signalhandler duerfen nur async-signal-safe Funktionen aufgerufen werden; siehe Manpage
signal-safety(7). ${1:`!p snip.rv = var()`}(3) ist keine solche Funktion. (-1.0)
endsnippet

context "c() and rush()"
snippet rush_sigsuspend_background "sigsuspend() wartet auf Hintergrundprozesse"
Hier muss sichergestellt werden, dass sigsuspend(3) nicht durch das Beenden eines
Hintergrundprozesses zurueckkehrt: hier muss ja auf den eben gestarteten Vordergrundprozess
gewartet werden. Um das zu realisieren, kann eine Variable aehnlich wie im Foliensatz unter 3.2
verwendet werden. (-2.0)
endsnippet

context "c() and rush()"
snippet rush_sleep_signals_unblocked "Signale waehrend sleep() nicht blockiert"
Waehrend sleep(3) ausgefuehrt wird, muss sichergestellt sein, dass "kein Signal dafuer sorgen kann,
dass sleep(3) vorzeitig zurueckkehrt" (siehe Aufgabenstellung). (-1.0)
endsnippet
# }}}

# jbuffer {{{
context "c() and jbuffer()"
snippet jbuffer_atomic "Leseindex nicht atomic"
Der Leseindex muss als atomic deklariert werden (z.B. mittels "_Atomic"), da dieser mit
atomic-Funktionen (z.B. dem CAS) verwendet wird. (-0.5)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_atomic_unneeded "unnoetiges atomic"
Das muss nicht atomic sein. Dann wird der restliche Code etwas schoener, da der Wert dann ja direkt
verwendet und veraendert werden darf. ;)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_CAS_r_late_read "Leseindex bei CAS zu spaet ausgelesen"
Man darf sich hier auf keinen Fall den Wert vom Leseindex ("bb->${1:read}") erst bei dem CAS holen:
die Idee hinter der Schleife ist, dass man sich den Wert holt, Berechnungen durchfuehrt, und am
Ende vergleicht, ob noch der selbe Wert drin steht, wie zuvor. Dadurch soll ja erkannt werden, ob
ein anderer Thread in der Zwischenzeit "bbGet" aufgerufen hat, in welchem Fall das ganze dann
wiederholt werden muss. Hier wird der Wert zwei mal direkt nacheinander ausgelesen, und diese
miteinander verglichen, wobei diese in den allermeisten Faellen identisch sind. Deswegen wird hier
nicht korrekt erkannt, ob ein anderer Thread dazwischen kam, und das CAS ist hier kaputt. (-1.0)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_CAS_date_late_read "Datum erst nach CAS ausgelesen"
Das Datum muss zwingend innerhalb der CAS-Schleife entnommen werden. Sonst kann es (vor allem bei
einem vollen Ringpuffer) vorkommen, dass zwischen dem CAS und dem Entnehmen des Datums ein anderer
Thread den Wert ueberschreibt. Ein ausfuehrliches Beispiel dazu gibt es auch im Foliensatz, der in
der Besprechungsuebung gezeigt wird (Kapitel 7.1). (-1.0)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_errno_set_to_0 "errno wird auf 0 gesetzt"
Die errno darf von Bibliotheksfunktionen niemals auf den Wert 0 gesetzt werden. POSIX gibt zwar nur
die Garantie, dass keine POSIX-Funktion die errno auf 0 setzt, aber im C11-Standard heisst es:
"[errno] is never set to zero by any library function". (C11 §7.5 Abs. 3)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_fam "kein FAM verwendet"
Hier kann man auch einen Flexible Array Member (siehe halde) verwenden. ;)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_free_jbuffer_c "Belegte Ressourcen im Fehlerfall nicht freigegeben (jbuffer.c)"
"If an error occurs during the initialization, the implementation frees all resources already
allocated by then." (-1.0)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_free_sem_c "Belegte Ressourcen im Fehlerfall nicht freigegeben (sem.c)"
"If an error occurs during the initialization, the implementation frees all resources already
allocated by then and sets @c errno to an appropriate value." (-1.0)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_int "int statt size_t fuer Leseindex (und Kopie davon)"
"`!p snip.rv = var()`" und der Leseindex ("bb->${1:read}") sind "int"s. Das ist problematisch, da
"`!p snip.rv = var()` + 1" bereits ausserhalb des gueltigen Wertebereichs (d.h. groesser als
"INT_MAX") sein kann - naemlich genau dann, wenn "bb->${2:size}" exakt "INT_MAX" betraegt. Um
dieses Problem zu loesen, muessen sowohl "`!p snip.rv = var()`" als auch "$1" vom Typ "size_t"
sein. (-1.0)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_NULL_check "Vergleich mit NULL fehlt fuer Argument"
"`!p snip.rv = var()`" muss hier noch auf NULL geprueft werden, in welchem Fall die Funktion
gar nichts machen soll. (-0.5)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_p_null_return "return bei NULL-Argument in P() bzw. V()"
Das ist nicht so spezifiziert, und in vielen Faellen ist hier ein Segmentation Fault wahrscheinlich
wirklich sinnvoller: dadurch merkt der Benutzer immerhin, dass er etwas falsch macht. So ein
stilles Fehlschlagen bzw. Nichtstun ist nicht so schlau, da ${1:P}() ja erwartungsgemaess auch
blockieren kann.
endsnippet

context "c() and jbuffer()"
snippet jbuffer_sem_negative_counter "Negativer Counter nicht beruecksichtigt"
Eine Semaphore kann auch mit einem negativen Wert initialisiert werden, um Signalisierung zu
implementieren. Das wird hier nicht beruecksichtigt. (-1.0)
endsnippet

context "c() and jbuffer()"
snippet jbuffer_size_int_max "size nicht auf > INT_MAX geprueft"
Wenn "`!p snip.rv = var()`" groesser als "INT_MAX" ist, dann wird in der Semaphoren-Implementierung
der Wert abgeschnitten, da "semCreate" ja nur einen "int" als Parameter nimmt. Eine Abfrage
diesbezueglich sollte immer dann erfolgen, wenn man in einen kleineren Datentypen umwandelt, was
hier implizit passiert. (-0.5)
endsnippet
# }}}

# mother {{{
context "c() and mother()"
snippet mother_cloexec_clientSock "clientSock FD_CLOEXEC nicht gesetzt"
"clientSock" muss noch mit dem Close-on-Exec-Flag versehen werden, damit dieser nicht an
aufgerufene Perl-Skripte vererbt werden. Das geht mittels fcntl(2). (-1.0)
endsnippet

context "c() and mother()"
snippet mother_dup_cloexec "Kein FD_CLOEXEC nach dup()"
Unmittelbar nach dem dup(2) muss der neue Deskriptor ebenfalls mit dem Close-on-Exec-Flag versehen
werden. Dies geschieht am besten, indem man anstelle von dup(2) einfach fcntl(2) mit dem Kommando
"F_DUPFD_CLOEXEC" aufruft, um das Duplizieren und Setzen des FD_CLOEXEC-Bits in einem (für den
Prozess) atomaren Schritt auszufuehren. (-1.0)
endsnippet

context "c() and mother()"
snippet mother_file_cloexec "FD_CLOEXEC nicht bei geoeffneten Dateien gesetzt"
Es waere schoen, wenn auch die geoeffneten Dateien das Close-on-Exec-Flag bekommen wuerden, selbst
wenn es in der Aufgabenstellung nicht explizit gefordert ist. Damit dies ohne Wettlaufsituation
gelingt, muss zunaechst open(2) mit dem O_CLOEXEC aufrufen. Wenn man anschließend die auf FILE*
arbeitenden Funktionen (wie z.B. fgets(3)) nutzen moechte, muss noch ein fdopen(3) verwendet
werden.
endsnippet

context "c() and mother()"
snippet mother_late_cloexec_clientSock "clientSock FD_CLOEXEC zu spaet gesetzt"
Es ist zwingend notwendig, das Close-on-Exec-Flag auf "clientSock" bereits *vor* dem Hinzufuegen
zum Puffer vorzunehmen. Sonst ist es bei einem sehr großen Puffer, schnell hintereinander
eintreffender Anfragen und wenig Threads mit steigender Wahrscheinlichkeit moeglich, dass ein
anderer Thread ein exec(2) ausfuehrt, bevor dieser Dateideskriptor mit dem Flag versehen wird.
Dadurch dass sich alle Threads einen Adressraum teilen, koennen auch ueber Threads hinweg die
Dateideskriptoren an Kinder vererbt werden. Das ist ein Problem das sich nicht vollends loesen
laesst, aber den Dateideskriptor hier womoeglich lange ungeschuetzt in der Queue zu lassen ist
keine gute Idee. (-0.5)
endsnippet

context "c() and mother()"
snippet mother_race_dup_cloexec "Race Condition durch dup() + fcntl()"
Hier existiert eine kleine Race Condition: zwischen dem dup(2) und dem fcntl(2) ist das
Close-on-Exec-Flag nicht gesetzt. Wenn also genau hier ein fork(2) in einem anderen Thread
aufgerufen wird, wird der Dateideskriptor hier auch nach dem exec(2) offen bleiben. Deswegen ist es
am besten, hier einfach fnctl(2) mit dem Kommando "F_DUPFD_CLOEXEC" aufruft, um das Duplizieren und
Setzen des FD_CLOEXEC-Bits in einem (für den Prozess) atomaren Schritt auszufuehren.
endsnippet

context "c() and mother()"
snippet mother_scandir "scandir() nicht verwendet"
Statt opendir(3) + readdir(3) sollte man lieber scandir(3) verwenden, da das den Code deutlich
simpler macht. ;)
endsnippet
# }}}

# }}}
