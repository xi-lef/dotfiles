# vim: fdm=marker tw=99 et
# Global {{{
global !p
# Accept extra spaces to be more robust with regard to pre-existing grading comments.
re_start = r'^\s*/\*K\s*\^?$'  # /*K ^
re_end = r'^\s*\*/$'  # */

# Check if we are in a multiline-grading-comment.
def c():
    for l in reversed(snip.buffer[: snip.line]):
        if re.match(re_end, l):
            return False
        elif re.match(re_start, l):
            return True
    return False

# Used for task-specific snippets.
def in_task(*names: str):
    return all(name in snip.buffer.name for name in names)

# Tasks with more than one .c-file have a "file"-parameter; a default value is given if the task
# focuses on one specific file, while other files have a minor role.
def lilo(): return in_task('lilo')
def wsort(): return in_task('wsort')
def halde(file = 'halde.c'): return in_task('halde', file)
def clash(file = 'clash.c'): return in_task('clash', file)
def mach(file = 'mach.c'): return in_task('mach', file)
def creeper(): return in_task('creeper')
def snail(): return in_task('snail')
def sister(file = ''): return in_task('sister', file)
def rush(): return in_task('rush')
def jbuffer(file = ''): return in_task('jbuffer', file)
def mother(file = ''): return in_task('mother', file)

# Get the name of the variable that the '^' at the start of the current grading-comment points to.
# The '^' can point to any character that is part of the variable; it does not need to be precise.
# "x_offset" can be used to offset the start point of the search for the variable name; see the
# snippet "pointer_dot_arrow" for an example of how this can be used.
def var(x_offset = 0, re_start = re_start):
    w = vim.current.window
    y = w.cursor[0] - 1

    y_arrow = next(i for i, l in reversed(list(enumerate(w.buffer[: y])))
                                 if re.match(re_start, l))
    x_arrow = w.buffer[y_arrow].find('^')
    if x_arrow == -1: return 'var'

    line = w.buffer[y_arrow - 1]
    # Replace tabs with the appropriate amount of spaces so the x-position is correct.
    line = line.replace('\t', ' ' * vim.current.buffer.options['tabstop'])
    # Search for the first invalid character to the left of the '^' to find the beginning of the
    # variable name.
    m = re.search(r'\W', line[x_arrow :: -1])
    offset = 0 if not m else max(0, m.start(0) - 1)

    m = re.search(r'\w+', line[x_arrow - offset :])
    if x_offset:
        # Search again, this time starting at the position of the match offset by "x_offset".
        m = re.search(r'\w+', line[x_arrow - offset + m.start(0) + x_offset :])
    return m[0] if m else 'var'
endglobal
# }}}

# General {{{
context "c()"
snippet 0_zero_null "0 statt NULL"
Bei Pointern ist es schoener, NULL statt 0 zu verwenden.
endsnippet

context "c()"
snippet access_existence_check "access() zur Existenz-Pruefung genutzt"
Manpage access(2): "Warning: Using these calls to check if a user is authorized to, for example,
open a file before actually doing so using open(2) creates a security hole, because the user might
exploit the short time interval between checking and opening the file to manipulate it. For this
reason, the use of this system call should be avoided." Das trifft hier zwar nicht exakt zu, aber
das Problem der beschriebenen Race Condition besteht trotzdem. Der access(2)-Aufruf hier ist
sowieso unnoetig: wenn die Datei nicht ${1|existiert,gelesen werden kann|}, wird eben der folgende
${2:fdopen(3)}-Aufruf fehlschlagen. Dann kann man es dort abfangen.
endsnippet

context "c()"
snippet argc_check "argc nicht geprueft"
Es muss noch geprueft werden, ob in "argc" der erwartete Wert steht. Sonst geht ein simpler Aufruf
wie "./`!v expand('%:r')`" kaputt, da einfach auf argv-Eintraege zugegriffen wird, die NULL sind.
Stattdessen soll in diesem Fall eine Fehlermeldung ausgegeben werden, die sagt, wie man das
Programm korrekt aufruft (siehe auch Referenzimplementierung). (-0.5)
endsnippet

context "c()"
snippet argc_imprecise "argc ungenau geprueft"
Die erlaubten Werte fuer argc sind hier klar eingeschraenkt; es waere also sehr sinnvoll, das auch
klar abzupruefen. Wenn *irgendein* unerlaubter Wert in argc steht, sollte der Benutzer auf die
korrekte Verwendung hingewiesen werden.
endsnippet

context "c()"
snippet atoi_strtol "atoi() statt strtol()"
atoi(3) darf nicht  verwendt werden, da man damit keine Fehler abfangen kann: es kann z.B. nicht
unterschieden werden, ob die Eingabe eine 0 war, oder ein Fehler aufgetreten ist. Stattdessen muss
strtol(3) verwendet werden (siehe auch Korrekturhinweise auf der Webseite). (-2.0)
endsnippet

context "c()"
snippet cast_void "void* unnoetig gecastet"
Ein void-Pointer kann implizit auf jeden anderen Pointer-Typen gecastet werden. Dieser explizite
Cast ist also unnoetig; man kann ihn fuer bessere Lesbarkeit weglassen. ;)
endsnippet

context "c()"
snippet char_array_sizeof "kein sizeof() fuer char-Array"
Da "${1:arr}" als "char"-Array definiert ist, kann man hier "sizeof($1)" verwenden. Dadurch muss
die Groesse nicht explizit doppelt angegeben werden, und es koennen nicht versehentlich
unterschiedliche Werte genutzt werden. ;)
endsnippet

context "c()"
snippet closedir "closedir() fehlt"
Das muss mit closedir(3) wieder geschlossen werden. (-1.0)
endsnippet

context "c()"
snippet debug_output "Debug-Ausgaben enthalten"
Solche Debug-Ausgaben bitte vor der Abgabe entfernen, so was gehoert nicht in ein fertiges Programm
(was die Abgabe darstellen sollte ;)).${1: (-0.5)}
endsnippet

context "c()"
snippet dup_fdopen_error_handling "dup() + fdopen() ohne dup()-Fehlerbehandlung"
Eine Fehlerbehandlung von dup(2) ist zwar nicht zwingend notwendig, da es quasi beim fdopen(3)
abgefangen wird. Trotzdem waere sie ganz nett, damit es ggf. eine bessere Fehlermeldung gibt. ;)
endsnippet

context "c()"
snippet dup2_order "falsche Reihenfolge der Argumente fuer dup2()"
Hier ist die Reihenfolge der Argumente falsch rum. Das zweite Argument ist der Dateideskriptor, der
zuerst geschlossen wird (quasi mit close(2)), und dann wird der erste Dateideskriptor dupliziert
(und verwendet den gerade geschlossenen Dateideskriptor wieder). Oder anders formuliert: der zweite
Dateideskriptor wird auf den ersten Dateideskriptor "umgebogen" (siehe auch Manpage dup2(2)). (-0.5)
endsnippet

context "c()"
snippet duplicate_function "doppelter Code, der in eine Funktion ausgelagert werden sollte"
Dieser Code kommt an mehreren Stellen identisch vor: man koennte ihn problemlos in eine
Hilfsfunktion auslagern. Dadurch spart man sich Schreibarbeit, und es ist auch leichter, diesen
Code zu veraendern, da man ihn dann nur an einer Stelle (anstatt an Mehreren) veraendern muss.
Das eliminiert also eine haeufige Fehlerquelle. ;)
endsnippet

context "c()"
snippet duplicate_if_else "doppelter Code in if- und else-Fall"
Hier ist im if- und else-Fall teilweise der gleiche Code; um diesen doppelten Code zu vermeiden,
kann man ihn einfach direkt hinter das if-else schreiben. Dadurch spart man sich Schreibarbeit, und
es ist auch leichter, diesen Code zu veraendern, da man ihn dann nur an einer Stelle (anstatt an
Mehreren) veraendern muss. Das eliminiert also eine haeufige Fehlerquelle. ;)
endsnippet

context "c()"
snippet errno_overwritten "errno durch Funktionsaufruf ueberschrieben"
Durch diesen Funktionsaufruf wird potentiell die errno ueberschrieben, wodurch perror(3) danach
eine falsche Fehlermeldung ausgeben koennte. Korrekt waere hier, die errno zu sichern, und nach dem
Funktionsaufruf wiederherzustellen.${1: (-0.5)}
endsnippet

context "c()"
snippet errno_no_perror "kein perror() trotz gesetzter errno"
In diesem Fall ist die errno gesetzt (durch ${1:func(3)}), weswegen hier perror(3) verwendet
werden sollte, um eine passende Fehlermeldung auszugeben. Als Argument fuer perror(3) uebergibt man
dann einfach den Namen der fehlgeschlagenen Funktion, also hier "perror("${1/([^(]+).*/$1/}")".
endsnippet

context "c()"
snippet errno_undefined "errno im (potentiellen) Erfolgsfall verwendet"
Wenn eine Bibliotheksfunktion erfolgreich war, ist der Wert der errno undefiniert (siehe auch
Manpage errno(3)). Hier darf also nicht der Wert der errno zur Fehlerbehandlung verwendet werden;
stattdessen muss der Rueckgabewert von "${1:func(3)}" genutzt werden. (-0.5)
endsnippet

context "c()"
snippet error_handling "Fehlerbehandlung fehlt"
Fehlerbehandlung fehlt. (-${1|1.0,0.5,1.5,2.0|})
endsnippet

context "c()"
snippet error_handling_unneeded_output "unnoetige Fehlerbehandlung bei nichtessentieller Ausgabe"
Diese Ausgabe zaehlt nicht zur Grundfunktionalitaet des Programmes; man braucht hier
dementsprechend nicht unbedingt eine Fehlerbehandlung (siehe auch Korrekturhinweise auf der
Webseite unter "Fehlerbehandlung bei Ein-/Ausgabe"). Sie schadet aber auch nicht. :)
endsnippet

context "c()"
snippet exec_exit "kein exit() nach exec()"
Eine Funktion der exec(3)-Familie (wie z.B. `!p snip.rv = var()`(3)) kehrt nur zurueck, wenn ein
Fehler aufgetreten ist (da im Erfolgsfall das aktuelle Programm quasi komplett ersetzt wird, und es
dementsprechend nicht mal moeglich waere, zu returnen). Hiernach muss also noch eine
Fehlerbehandlung kommen (wobei der Rueckgabewert dann nicht betrachtet werden muss). (-1.0)
endsnippet

context "c()"
snippet execv_execl "execv() anstatt execl() verwendet"
Hier kann man auch exec${1|l,lp|}(3) verwenden; dort kann man die Argumente direkt uebergeben,
anstatt zuerst das Array extra anlegen zu muessen. ;)
endsnippet

context "c()"
snippet fclose "fclose() fehlt"
Das muss mit fclose(3) wieder geschlossen werden. (-1.0)
endsnippet

context "c()"
snippet fclose_close_double "doppeltes Schliessen durch close() + fclose()"
fclose(3) schliesst auch den darunterliegenden Dateideskriptor, d.h. dieses close(2) ist falsch; es
kann und muss einfach weggelassen werden, damit der Dateideskriptor nicht doppelt geschlossen wird.
(-0.5)
endsnippet

context "c()"
snippet fdopen_without_dup "mehrere fdopen() auf demselben Dateideskriptor"
Hier wird derselbe Dateideskriptor wie beim obigen fdopen(3)-Aufruf verwendet. Das funktioniert
nicht, da bei einem folgenden fclose(3) der darunterliegende Dateideskriptor geschlossen wird.
Dadurch wuerde also derselbe Dateideskriptor mehrmals geschlossen werden, das nicht korrekt ist.
Siehe Foliensatz zur snail, 1.4. (-1.0)
endsnippet

context "c()"
snippet ferror_feof "ferror()/feof() fehlt"
Fuer eine korrekte Fehlerbehandlung muss hier noch ferror(3) oder feof(3) betrachtet werden, um zu
wissen, ob ein Fehler aufgetreten ist, oder lediglich EOF erreicht wurde. (-0.5)
endsnippet

context "c()"
snippet fflush "fflush() fehlt"
Hier muss noch ein fflush(3) samt Fehlerbehandlung stehen, um sicherzugehen, dass die Ausgabe
auch wirklich rausgeschrieben wird. Sonst kann es sein, dass die Ausgabe bis jetzt nur in einem
Puffer gespeichert, aber noch nicht tatsaechlich rausgeschrieben wurde. (-1.5)
endsnippet

context "c()"
snippet fgetc_type "char als Rueckgabetyp bei [f]getc()"
[f]getc returnt einen "int", d.h. das muss auch in einem "int" gespeichert werden, damit die
Fehlerbehandlung (konkret: der Vergleich mit "EOF") korrekt funktionieren kann. EOF ist
ueblicherweise als -1 definiert; ein "char" ist z.B. ein unsigned 8-Bit Wert, d.h. hat einen
Wertebereich von [0, 255]. Es ist also nicht moeglich, zwischen -1 und 255 zu unterscheiden,
da - als 8-Bit Wert betrachtet - beides gleich ist: 0xff. (-1.0)
endsnippet

context "c()"
snippet fgets_size "falsche size bei fgets()"
fgets(3) muss hier die Groesse des uebergebenen Puffers ("${1:buf}") uebergeben werden; das
beinhaltet also auch den Platz fuer das '\0'. (Wenn "$1" ein "char"-Array ist, kann auch direkt
"sizeof($1)" verwendet werden - dann kann dieser Fehler gar nicht passieren.) (-0.5)
endsnippet

context "c()"
snippet format_string_attack "Format-String Angriff moeglich"
Das ist problematisch, da "${1:`!p snip.rv = var()`}" ein String vom Benutzer ist, aber von printf
als Format-String interpretiert wird. Wenn der Benutzer hier also z.B. ein "%d" reinschreibt, wird
das, was als naechstes auf dem Stack liegt, als Dezimalzahl ausgegeben. In solchen Faellen muss
deswegen immer "%s" als Format-String verwendet werden. (-1.0)
endsnippet

context "c()"
snippet format_string_indirection "unnoetige Indirektion im Format-String"
Das kann man auch direkt in den Format-String schreiben. ;)
endsnippet

context "c()"
snippet free "free() fehlt"
Das muss mit free(3) wieder freigegeben werden. (-1.0)
endsnippet

context "c()"
snippet free_null "free(NULL)"
Das hier ist effektiv ein "free(NULL)", was gar nichts macht, wie auch in der Manpage von free(3)
beschrieben ist. Man kann es also einfach weglassen. ;)
endsnippet

context "c()"
snippet free_in_error_case "Ressourcen im Fehlerfall freigegeben"
Im Fehlerfall muessen keine Ressourcen freigegeben werden, wenn das Programm im Rahmen der
Fehlerbehandlung beendet wird. Dadurch kann der Code etwas kurzer/uebersichtlicher bleiben. ;)
endsnippet

context "c()"
snippet freeaddrinfo "freeaddrinfo() fehlt"
Das muss mit freeaddrinfo(3) wieder freigegeben werden. (-1.0)
endsnippet

context "c()"
snippet global_init "unnoetige Initialisierung von globaler Variable"
(Modul-)globale Variablen werden standardmaessig mit 0 (bzw. NULL fuer Pointer) initialisiert. Das
muss man hier also nicht explizit machen. ;)
endsnippet

context "c()"
snippet global_unneeded "unnoetig globale Variable"
Diese Variable ist unnoetig global und koennte genauso gut eine lokale Variable in "${1:func}"
sein. (-0.5)
endsnippet

context "c()"
snippet if_return_else "unnoetiger else-Fall nach return im if-Fall"
Da im if-Fall bereits ein "${1|return,break,continue|}" steht, braucht man hier kein extra "else".
Der Code wird ja sowieso nur ausgefuehrt, wenn der if-Fall nicht betreten wurde. Das macht den Code
etwas uebersichtlicher. ;)
endsnippet

context "c()"
snippet if_success "if-Fall ist Erfolgsfall statt Fehlerfall"
Hier steht der Code des Erfolgsfalls im if, wodurch das hier eine sehr lange if-Anweisung ist. Im
Allgemeinen ist es deswegen oft besser, den Fehlerfall abzufangen, in welchem man dann z.B. ein
fruehzeitiges "${1|return,break,continue,exit|}" machen kann - dafuer muss man letztendlich nur die
if-Bedingung invertieren. Insgesamt wird der Code dadurch deutlich uebersichtlicher.
endsnippet

context "c()"
snippet indentation "schlechte Einrueckung"
Der Code war teilweise schlecht eingerueckt bzw. formatiert, was es deutlich erschwert, den Code zu
verstehen; ich habe das fuer die Korrektur mal behoben. Es gibt viele Wege, Code "automatisiert"
einzuruecken: die meisten IDEs z.B. haben ein Feature dafuer. In der Kommandozeile gibt es auch
clang-format(1), welches man einfach mit "clang-format -i `!v expand('%')`" verwenden kann. In Vim
z.B. kann man auch einfach die Tastenfolge "gg=G" (im "Normal mode") druecken, um die aktuelle
Datei korrekt einzuruecken.
endsnippet

context "c()"
snippet library_perror_exit "perror() oder exit() in Bibliotheksfunktion"
Diese Funktion ist als Bibliotheksfunktion zu betrachten, deswegen darf hier weder perror(3) noch
exit(3) verwendet werden. Die Ausgabe einer Fehlermeldung bzw. das Beenden des Programmes soll die
Entscheidung des Aufrufers sein. (-${1|0.5,1.0|})
endsnippet

context "c()"
snippet linux_header "Inkludieren eines Linux-Headers"
Einen Linux-Header zu inkludieren ist in SP quasi immer falsch, da man portabel zu der
POSIX-Schnittstelle programmieren soll. Wenn man so einen Header braucht, sollte man (in SP) seinen
Ansatz nochmal ueberdenken.
endsnippet

context "c()"
snippet malloc_instead_of_stack "malloc() statt Stack-Allokation"
Das haette man auch auf dem Stack machen koennen. Das spart die Fehlerbehandlung und das free(3)
spaeter, was insgesamt deutlich angenehmer ist. ;)
endsnippet

context "c()"
snippet malloc_zero "malloc(0)"
malloc(0) *darf* NULL returnen (siehe halde). Deshalb ist es falsch, hier anzunehmen, dass NULL
einen Fehlerfall darstellt. (-0.5)
endsnippet

context "c()"
snippet nullbyte "Platz fuer '\0' fehlt"
Hier fehlt ein Byte fuer das '\0'. (-0.5)
endsnippet

context "c()"
snippet perror_no_errno "perror() trotz ungesetzter errno"
In diesem Fall ist die errno nicht gesetzt, deswegen kann hier perror(3) nicht verwendet werden.
Man muss hier mit fprintf(3) selbst eine aussagekraeftige Fehlermeldung schreiben. (-0.5)
endsnippet

context "c()"
snippet pid_t_assumed_int "Annahme, dass ein pid_t ein int ist"
Ein pid_t ist nicht unbedingt ein int. So weit ich das sehe, ist laut POSIX lediglich gegeben, dass
ein pid_t signed und maximal ein long ist; siehe Manpage system_data_types(7).
Ein Weg das hier zu pruefen, waere, den Wert von strtol(3) auf einen pid_t zu casten, und dann die
beiden Werte (also den long und den pid_t) zu vergleichen. Wenn sie ungleich sind, wurde der Wert
wohl abgeschnitten, und man sollte besser nicht weitermachen. Leider ist das Verhalten bei einem
Cast in einen "kleineren" Datentypen aber Implementation-defined: es ist leider nicht garantiert,
dass das so funktioniert.
endsnippet

context "c()"
snippet pointer_dot_arrow "(*ptr).member statt ptr->member"
Beim Zugriff auf den Member einer Struktur durch einen Pointer sollte man lieber die "->"-Syntax
verwenden, da das leserlicher ist. Hier waere das also "`!p
ptr = var()
member = var(len(ptr))
snip.rv = f'{ptr}->{member}'
`". ;)
endsnippet

context "c()"
snippet pthread_errno "pthread-Funktion-Rueckgabewert nicht in errno gespeichert"
Saemtliche pthread-Funktionen setzen die errno(3) nicht selbst, d.h. der Rueckgabewert von z.B.
`!p snip.rv = var()`(3) muss noch explizit in der errno gespeichert werden, damit danach perror(3)
verwendet werden kann. (-0.5)
endsnippet

context "c()"
snippet pthread_id_array "Thread-ID unnoetigerweise gespeichert"
Da die Thread-IDs spaeter nicht mehr verwendet werden (z.B. fuer ein pthread_join(3)), ist es
unnoetig, hier alle IDs in einem Array abzuspeichern. ;)
endsnippet

context "c()"
snippet readdir_comma "fuer readdir() nicht Komma-Operator genutzt"
Noch schoener geht das Setzen der errno mithilfe des Komma-Operators direkt im Kopf der
while-Schleife: "while (errno = 0, ent = readdir(dir)) { ... } ". ;)
endsnippet

context "c()"
snippet readdir_errno "errno vor readdir() nicht auf 0 gesetzt"
Die errno muss vor jedem readdir(3)-Aufruf auf 0 gesetzt werden. Sonst ist es nicht moeglich,
zwischen einem Fehler und end-of-directory-stream zu unterscheiden (siehe auch Manpage). Am
schoensten geht das mithilfe des Komma-Operators direkt im Kopf der while-Schleife:
"while (errno = 0, ent = readdir(dir)) { ... } ". (-0.5)
endsnippet

context "c()"
snippet realloc_tmp "unnoetigte temporaere Variable fuer realloc"
Hier kann man auch direkt "${1:ptr}" verwenden, da im Fehlerfall das Programm eh beendet wird.
endsnippet

context "c()"
snippet return_stack_pointer "Pointer auf lokale Variable wird returnt"
"${1:`!p snip.rv = var()`}" ist eine lokale Variable, d.h. sie liegt auf dem Stack. Sobald aus
dieser Funktion returnt wird, ist "$1" damit nicht mehr gueltig; das kann also nicht so returnt
werden. (-1.0) Eine simple Alternative ist hier, den Heap (d.h. malloc(3)) zu verwenden.
endsnippet

context "c()"
snippet same "Gleiches wie oben"
Gleiches wie ${1:oben}.${2:`!p
w = vim.current.window
y = w.cursor[0] - 1

# Use default value for both next()s just in case there is no previous comment.
y_end = next((i for i, l in reversed(list(enumerate(w.buffer[: y])))
                            if re.match(re_end, l)), 0)
y_start = next((i for i, l in reversed(list(enumerate(w.buffer[: y_end])))
                              if re.match(re_start, l)), 0)
m = re.search(r'\(-([0-9.]+)\)', ''.join(w.buffer[y_start : y_end]))
snip.rv = f' (-{m[1]})' if m else ''
`}
endsnippet

context "c()"
snippet semdestroy "semDestroy() fehlt"
Das muss mit semDestroy() wieder freigegeben werden. (-1.0)
endsnippet

context "c()"
snippet sigaction_unneeded_flags "unnoetiges Setzen der sa_flags fuer sigaction()"
Dieses Flag ist nur relevant, wenn man eine Signalbehandlungsfunktion installiert. Bei SIG_IGN bzw.
SIG_DFL ist es irrelevant.
endsnippet

context "c()"
snippet sigaction_unneeded_mask "unnoetiges Setzen der sa_mask fuer sigaction()"
Die "sa_mask" ist nur relevant, wenn man eine Signalbehandlungsfunktion installiert. Bei SIG_IGN
bzw. SIG_DFL ist sie irrelevant.
endsnippet

context "c()"
snippet sizeof_char "sizeof(char) statt 1"
"sizeof(char)" ist in C immer 1; man kann sich das also sparen. ;)
endsnippet

context "c()"
snippet sizeof_for_strlen "sizeof() statt strlen()"
"sizeof(${1:`!p snip.rv = var()`})" gibt die Groesse von "$1" zurueck, was ein Pointer und damit
ueblicherweise 8 ist. Dies wird schon beim Compilen ermittelt. Hier will man aber die Laenge von
dem String, der hinter dem Pointer steht, welche man mit strlen(3) ermittelt. (-1.0)
endsnippet

context "c()"
snippet sizeof_pointer "sizeof(ptr) statt sizeof(*ptr)"
"sizeof(${2:`!p snip.rv = var()`})" gibt die Groesse von "$2" zurueck, was ein
"struct ${1:listelement} *" ist. Hier wird also nur genug Speicher fuer einen Pointer reserviert,
nicht aber fuer ein eigentliches "struct $1". Korrekt waere hier z.B. "sizeof(*$2)". (-0.5)
endsnippet

context "c()"
snippet static "Hilfsfunktion/-variable nicht static"
Hilfsfunktionen/-variablen muessen static sein, damit diese nicht fuer andere Module sichtbar sind.
(-${1|0.5,1.0|})
endsnippet

context "c()"
snippet stderr_stdout_error_message "Fehlerausgaben auf stdout"
Fehlermeldungen gehoeren auf stderr. Das geht am einfachsten mit fprintf(3). (-0.5)
endsnippet

context "c()"
snippet strdup_malloc_strcpy "malloc() + strcpy() statt strdup()"
Hier kann man auch direkt strdup(3) verwenden, was das Allokieren des Speichers und das Kopieren
des Strings in einer Funktion macht. Das ist etwas schoener. ;)
endsnippet

context "c()"
snippet strtol_endptr "strtol(): endptr nicht verwendet"
Hier muss "endptr" verwendet werden, um zwei Fehler abpruefen zu koennen: erstens kann der String
leer sein, in welchem Fall einfach 0 returnt wird. Zweitens koennen nach der eigentlich Zahl noch
Buchstaben enthalten sein (z.B. "123a"), was ja auch nicht sein soll. Siehe auch Manpage strtol(3).
(-0.5)
endsnippet

context "c()"
snippet strtol_errno "strtol(): errno nicht gesetzt und geprueft"
Vor dem Aufruf von strtol(3) muss die errno(3) auf 0 gesetzt werden. Da strtol(3) die errno im
Erfolgsfall unveraendert laesst, kann man so durch das Betrachten der errno bestimmte Fehler (genau
genommen: ERANGE) abfangen. Siehe auch das Beispiel in der Manpage strtol(3). (-0.5)
endsnippet

context "c()"
snippet todo_comment "TODO im Code"
Normalerweise loescht man einen "TODO"-Kommentar, nachdem man ihn erledigt hat. ;)
endsnippet

context "c()"
snippet unreadable_global "unlesbarer Code durch (viele) globale Variablen"
Globale Variablen erschweren die Lesbarkeit des Codes stark, da nicht direkt klar ist, wo sie
veraendert und verwendet werden. Das macht es schwieriger fuer mich, den Code zu lesen, und es ist
auch deutlich leichter, Fehler beim Schreiben des Codes zu machen. Man sollte diese Werte eher als
Argumente an Funktionen uebergeben und als Rueckgabewerte zurueckgeben, dadurch kann man dem
Datenfluss deutlich besser folgen. (-0.5)
endsnippet

context "c()"
snippet unreadable_nested "unlesbarer Code durch starke Verschachtelung"
Der Code hier ist sehr stark verschachtelt, was die Lesbarkeit deutlich verschlechtert. Prinzipiell
sollte man eher Fehlerfaelle explizit abfangen, und dort dann ein fruehzeitiges "return",
"continue", "break", oder exit(3) (je nachdem, was zutrifft) machen. Dann braucht man naemlich den
darauf folgenden Erfolgsfall nicht in ein "else" zu stecken, und hat nicht so tiefe
Verschachtelung, was alles uebersichtlicher macht.
endsnippet

context "c()"
snippet unused "unverwendete Variable/Funktion"
"`!p snip.rv = var()`" wird im restlichen Code nie verwendet.
endsnippet

context "c()"
snippet variables_c89 "alle Variablen am Anfang deklariert"
Es gibt keinen Grund, alle Variablen am Anfang zu deklarieren. Wenn sie erst kurz vor der
Verwendung deklariert werden, ist das deutlich uebersichtlicher. :)
endsnippet

context "c()"
snippet void_return "return am Ende von void-Funktion"
Am Ende einer Funktion, die nichts zurueckgibt (also Rueckgabetyp "void"), braucht man kein
explizites "return". ;)
endsnippet
# }}}



# lilo {{{
context "c() and lilo()"
snippet lilo_access_freed_memory "Zugriff auf bereits freigegebenen Speicher"
Der Speicherbereich, auf den der Zeiger "${1:`!p snip.rv = var()`}" zeigt, ist zu diesem Zeitpunkt
bereits freigegeben. Der Zugriff auf einen freigegebenen Speicherbereich ist undefiniertes
Verhalten; "$1" darf also erst danach freigegeben werden. Hier muss der zurueckzugebende Wert
demnach in einer Variable zwischengespeichert werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_empty_list "leere Liste nicht korrekt behandelt"
Wenn die Liste leer ist, erfolgt ein Zugriff auf die Adresse NULL und das Programm wird
abgebrochen (Segmentation Fault). (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_error_message_output "Fehlerausgabe gemacht"
Laut Aufgabenstellung sollen keine Fehlermeldung ausgegeben werden: die Funktionen "insertElement"
und "removeElement" koennen als Bibliotheksfunktionen angesehen werden. Bei solchen Funktionen soll
der Aufrufer entscheiden, ob er eine Fehlermeldung ausgeben will, oder nicht. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_error_handling "Fehlerbehandlung fehlt"
Fehlerbehandlung fehlt. Wenn Funktionen (wie z.B. malloc(3)) mit einem Fehler zurueckkehren, dieser
aber nicht behandelt wird, fuehrt dies zum Programmabsturz. Deshalb muss man immer
Fehlerueberpruefungen durchfuehren, und auftretende Fehler entsprechend behandeln. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_first_element_unchecked "erstes Element nicht auf Gleichheit geprueft"
Das erste Element der Liste wird hier nicht mit dem einzufuegenden Wert verglichen, wodurch
womoeglich Werte doppelt eingefuegt werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_free_insert "free() fehlt in insertElement-Fehlerfall"
Wenn das bereits angelegte Listenelement gar nicht in die Liste eingefuegt wird, wird es spaeter
auch nie aus dieser entfernt. Der mit malloc(3) allokierte Speicher wird in diesem Fall also nicht
freigegeben: hier liegt ein Speicherleck vor. (-1.0)
endsnippet

context "c() and lilo()"
snippet lilo_free_remove "free() fehlt in removeElement"
Der Speicher, der vom entfernten Listenelement belegt wurde, muss noch freigegeben werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_last_element_unchecked "letztes Element nicht auf Gleichheit geprueft"
Das letzte Element der Liste wird hier nicht mit dem einzufuegenden Wert verglichen, wodurch
womoeglich Werte doppelt eingefuegt werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_main_list_functionality "Listenfunktionalitaet in main()"
Laut Aufgabenstellung darf keine Listenfunktionalitaet in der main()-Funktion implementiert werden;
sie soll lediglich zum Testen verwendet werden. Der Punkt davon ist, dass "insertElement" und
"removeElement" als Bibliotheksfunktionen betrachtet werden sollen - dementsprechend muessen sie
selbststaendig funktionieren, ohne diesen Code hier. (-1.0)
endsnippet

context "c() and lilo()"
snippet lilo_negative_values "negative Werte erlaubt"
Laut Aufgabenstellung soll die Funktion "insertElement" nur *nicht*-negative Werte in die Liste
einfuegen. Hier fehlt die entsprechende Pruefung. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_static_head "static (bei Head) vergessen"
Hier fehlt das Keyword "static": die Verwendung von globalen Variablen sollte vermieden werden
(siehe Vorlesung A II 7.5). Da in diesem Fall eine Variable mit erweiterter Sichtbarkeit und
Lebensdauer notwendig ist, muss eine modulglobale Variable verwendet werden. (-0.5)
endsnippet

context "c() and lilo()"
snippet lilo_uninitialized_values "uninitialisierte Werte durch malloc()"
Der Speicher fuer das Listenelement wurde mit malloc(3) angelegt und ist damit uninitialisiert
(d.h. es stehen zufaellige Werte im Speicher). Daher ist es notwendig, alle Strukturkomponenten zu
initialisieren; alternativ kann auch direkt calloc(3) verwendet werden, welches mit den Speicher
mit nullen initialisiert. (-0.5).
endsnippet

context "c() and lilo()"
snippet lilo_unneeded_global "unnoetig globale Variable"
Diese Variable ist unnoetigerweise global, allerdings sollte die Verwendung von globalen Variablen
vermieden werden (siehe Vorlesung A II 7.5). In diesem Fall reicht eine lokale Variable aus. (-0.5)
endsnippet
# }}}

# wsort {{{
context "c() and wsort()"
snippet wsort_102 "Puffer fuer Zeilen zu klein"
Laut Aufgabenstellung ist ein Wort maximal 100 Zeichen lang. Damit wird ein Puffer der Groesse 102
benoetigt, da zusaetzlich zum eigentlichen Wort noch ein '\n' (das laut Aufgabenstellung nicht zum
Wort gehoert) sowie ein '\0' dazu kommen. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_compare_const_type "const in compare() an falscher Stelle"
Der korrekte Typ waere hier genau genommen "char * const *", also ein Pointer auf einen konstanten
"char"-Pointer, da ja die Elemente des zu sortierenden Arrays (= "char"-Pointer) konstant sein
sollen.
endsnippet

context "c() and wsort()"
snippet wsort_compare_pointer "Pointer in compare() inkorrekt verwendet"
Diese Funktion wird von qsort(3) aufgerufen, und bekommt dabei *Pointer* auf die zu sortierenden
Elemente uebergeben. Diese Elemente sind hier Strings, also "char *"; diese Funktion bekommt also
Pointer auf Strings, also "char **" uebergeben. Hier werden nun die Pointer sortiert, es muessen
aber die Strings "dahinter" sortiert werden. Dafuer muessen die Argumente korrekt gecasted werden,
bevor sie verwendet werden. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_empty_lines "leere Zeilen nicht ignoriert"
Laut Aufgabenstellung sollen leere Zeilen ignoriert werden. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_fgets_err "Fehlerbehandlung fgets() fehlt"
Fehlerbehandlung fuer fgets(3) fehlt: sobald fgets(3) NULL zurueckgibt muss noch geprueft werden,
ob ein Fehler aufgetreten ist. Dafuer gibt es dann feof(3) bzw. ferror(3) (siehe auch
Korrekturhinweise auf der Webseite). (-1.5)
endsnippet

context "c() and wsort()"
snippet wsort_LF_last_line "letzte Zeile ohne '\n' falsch behandelt"
Laut Aufgabenstellung muss die letzte Zeile nicht zwangslaeufig ein '\n' enthalten - das geht hier
kaputt, da ${1:...} (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_LF_not_removed "'\n' ist Teil des Wortes"
Laut Aufgabenstellung ist das '\n' am Ende einer Zeile nicht Teil des Wortes. Hier werden diese nie
entfernt und dadurch mitsortiert, was zu einer falschen Sortierreihenfolge fuehrt. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_overlong_condition "unerfuellbare Bedingung zur Erkennung von ueberlangen Zeilen"
Diese Bedingung kann nie erfuellt sein, da fgets(3) nur ${1:101} Zeichen (exklusive '\0') einliest.
strlen(3) gibt die Laenge des Strings (also die Anzahl an Zeichen vor dem '\0') zurueck, was
niemals groesser sein kann. (-1.0)
endsnippet

context "c() and wsort()"
snippet wsort_overlong_missing "Behandlung von ueberlangen Zeilen fehlt"
Hier fehlt ${1:das Erkennen (-3.0) sowie }das Ignorieren (-2.0) von ueberlangen Zeilen.
endsnippet

context "c() and wsort()"
snippet wsort_static "static (bei Hilfsfunktion) vergessen"
Hier fehlt "static". Alle Schnittstellen, die nicht in der Aufgabenstellung verlangt sind, sollen
nach aussen hin nicht sichtbar sein. Ohne das "static" ist es anderen Modulen (mit denen dieses
Modul womoeglich zusammen gelinkt wird) erlaubt, ebenfalls diese Funktion zu verwenden. Das
verhindert einen erfolgreichen Link-Vorgang. (-0.5)
endsnippet
# }}}

# halde {{{
context "c() and halde()"
snippet halde_calloc_overflow "calloc: keine Overflow-Behandlung"
"nmemb * size" kann ueberlaufen ("Integer Overflow"), was man abfangen kann und sollte. Mehr dazu
in der Besprechungsuebung.
endsnippet

context "c() and halde()"
snippet halde_free_magic "free: MAGIC nicht geprueft"
Fuer "${1:`!p snip.rv = var()`}" muss noch geprueft werden, ob im dazugehoerigen "mblock->next"
wirklich "MAGIC" steht. Dazu soll sichergestellt werden, dass der uebergebene Pointer wirklich von
"malloc" kommt, und nicht einfach ein zufaelliger Pointer uebergeben wurde. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_function_local_static "keine funktionslokale static Variable"
Eine *funktionslokale* static Variable waere hier schoener, da das ja nur in "malloc" verwendet
wird. ;)
endsnippet

context "c() and halde()"
snippet halde_malloc_head_reinitialize "malloc: Reinitialisierung bei komplett belegtem Speicher"
Dieser Check funktioniert nicht ganz: falls der gesamte verwaltete Speicher belegt ist, wird hier
erneut Speicher vom Betriebssystem angefordert. Laut Aufgabenstellung soll das aber nur einmalig
(initial) erfolgen. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_malloc_always_create_mblock "malloc: neuer mblock in jedem Fall erstellt"
Hinter dem vergebenen Speicherbereich soll zwar prinzipiell ein neuer mblock erzeugt werden, um den
Rest des Speicherbereichs zu verwalten - falls das aber nicht geht, soll der aktuelle
"malloc"-Aufruf trotzdem bedient werden (weil ja noch genug Speicher verfuegbar ist). In diesem
Fall wuerde man dann eben keinen neuen mblock erzeugen, was komplett in Ordnung ist. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_malloc_size_modified "malloc: size faelschlicherweise verkleinert"
Die Groesse des vergebenen mblocks darf nur veraendert (also verkleinert) werden, wenn ein neuer
mblock dahinter angelegt wird. Sonst geht der Speicher, der vom vergebenen mblock nicht verwendet
wird, dauerhaft verloren. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_mblock_memory "mblock->memory nicht genutzt"
Hierfuer gibt es auch den sogenannten Flexible Array Member: "`!p snip.rv = var()`->memory". ;)
endsnippet

context "c() and halde()"
snippet halde_realloc_size_min "realloc: zu viel kopiert"
Hier duerfen maximal "min(size, ptr_mblock->size)" viele Bytes kopiert werden, da sonst ueber den
verwalteten Speicherplatz hinausgeschrieben wird, wobei die Daten in anderen mblocks ueberschrieben
werden koennten. (-1.0)
endsnippet

context "c() and halde()"
snippet halde_realloc_size_zero "realloc: size 0 nicht als free() behandelt"
Laut Aufgabenstellung soll sich "realloc(ptr, 0)" wie "free(ptr)" verhalten. Das fehlt hier. (-1.0)
endsnippet

# test.c {{{
context "c() and halde('test.c')"
snippet halde_test_edge_case "test: kein Randfall abgeprueft"
Laut Aufgabenstellung soll mindestens einer der in der Manpage beschriebenen Randfaelle abgeprueft
werden (mit einem Kommentar). (-0.5) Ideal waere sogar, alle Randfaelle abzupruefen. ;)
endsnippet

context "c() and halde('test.c')"
snippet halde_test_required "verlangte Aufrufe nicht vorhanden"
Laut Aufgabenstellung soll hier (mindestens) vier Mal "malloc" + Freigabe mit "free" + vier Mal
"malloc" getestet werden. Das ist leider gar nicht erfuellt. (-1.0)
endsnippet
# }}}
# }}}

# clash {{{
context "c() and clash()"
snippet clash_background_first_char "erstes Zeichen des letztens Tokens mit '&' vergleicht"
Man will hier nicht pruefen, ob das letzte Token mit einem '&' beginnt, sondern ob es ein "&" ist.
Sonst geht z.B. "echo &hallo" kaputt. (-0.5)
endsnippet

context "c() and clash()"
snippet clash_chdir_exit "exit() bei chdir"
Das ist ein Fall, wo es sinnvoll ist, das exit(3) wegzulassen: wenn man sich z.B. einfach nur beim
Pfadnamen vertippt, will man ja nicht, dass sich die ganze Shell beendet. ;)
endsnippet

context "c() and clash()"
snippet clash_duplicate_tokens "Duplizieren der Tokens (z.B. mit strdup())"
Das ganze Duplizieren der einzelnen Tokens ist komplett unnoetig. Man kann einfach die Tokens von
strtok(3) direkt speichern, da strtok(3) ja Nullbytes einfuegt, und einem dadurch quasi schon
"einzelne Strings" gibt.
endsnippet

context "c() and clash()"
snippet clash_fflush "fflush() beim Prompt fehlt"
Hier fehlt ein fflush(3), da sonst die Ausgabe nicht sicher auf das Terminal geschrieben wird, da
stdout standardmaessig zeilenweise gepuffert ist. Da nach dem Prompt (korrekterweise) kein '\n'
geschrieben wird, ist also ein fflush(3) noetig. (-0.5)
endsnippet

context "c() and clash()"
snippet clash_getcwd_err "Fehlerbehandlung getcwd() fehlt"
Fehlerbehandlung fuer getcwd() mit Vergroesserung des Puffers fehlt. (-3.0)
endsnippet

context "c() and clash()"
snippet clash_getcwd_errno "errno im getcwd()-Fehlerfall nicht geprueft"
Der Puffer darf hier nur vergroessert werden, wenn die errno "ERANGE" lautet, da ja auch andere
Fehler auftreten koennen, als dass der Puffer zu klein war (siehe Manpage). In anderen Faellen
braucht man noch eine normale Fehlerbehandlung. (-1.0)
endsnippet

context "c() and clash()"
snippet clash_getcwd_path_max "PATH_MAX fuer getcwd() verwendet"
"PATH_MAX" zu verwenden ist hier nicht korrekt: es muss das in der Manpage von getcwd(3)
beschriebene Vorgehen verwendet werden. Im Internet gibt es viele Erklaerungen, warum "PATH_MAX"
quasi nie verwendet werden sollte; eine gute und kompakte Erklaerung gibt es auch in der Manpage
von der aehnlichen Funktion realpath(3) in der Sektion 'BUGS'. (-3.0)
endsnippet

context "c() and clash()"
snippet clash_line_empty "Fehler bei leerer Eingabezeile"
Wenn die Eingabezeile leer ist (d.h. der Benutzer einfach Enter drueckt), fuehrt das zu einem
Fehler. Solche Zeilen sollen einfach ignoriert werden. (-1.0)
endsnippet

context "c() and clash()"
snippet clash_line_whitespace "Fehler bei Eingabezeile, die nur Whitespace enthaelt"
Wenn die Eingabezeile nur aus Trennzeichen besteht (z.B. einfach ein Leerzeichen), ist das nullte
Token bereits NULL, was ${1|hier,spaeter|} zu einem Segmentation Fault fuehrt. (-1.0)
endsnippet

context "c() and clash()"
snippet clash_overlong "ueberlange Zeilen nicht ignoriert"
Zu lange Zeilen muessen hier noch erkannt und mit einer Warnung verworfen werden (wie auch in der
wsort). (-3.0)
endsnippet

context "c() and clash()"
snippet clash_wexitstatus_wifexited "WEXITSTATUS() ohne vorheriges WIFEXITED()"
"WEXITSTATUS" darf laut der Manpage nur verwendet werden, wenn "WIFEXITED" true zurueckgibt. (-1.0)
endsnippet

context "c() and clash()"
snippet clash_wexitstatus "kein WEXITSTATUS() verwendet"
Das hier ist nicht der Exitstatus, dort stehen auch noch andere Informationen drin. Um an den
eigentlichen Exitstatus zu kommen, muss das Makro "WEXITSTATUS" verwendet werden (siehe Manpage).
(-1.0)
endsnippet

# plist.c {{{
context "c() and clash('plist.c')"
snippet clash_walklist "kein fruehzeitiges Abbrechen des Durchlaufens"
Hier fehlt die Beachtung der Abbruchbedingung, wenn "callback" 0 zurueckgibt (siehe plist.h).
Selbst wenn das in clash.c nie verwendet wird, muss das hier implementiert werden, da die plist
quasi als Bibliothek zu betrachten ist, und andere Nutzer der plist dieses Feature vielleicht
verwenden wollen. (-0.5)
endsnippet
# }}}
# }}}

# mach {{{
context "c() and mach()"
snippet mach_buffer_overwrite "Puffer fuer Befehlszeile wird ueberschrieben"
Dieser Puffer wird von jedem fgets(3)-Aufruf wiederverwendet, d.h. der Pufferinhalt wird bei jedem
Schleifendurchlauf ueberschrieben. Da dieser Puffer dann direkt an den Arbeiterthread uebergeben
wird, verwenden letztendlich alle Arbeiterthreads denselben Puffer, was natuerlich nicht
funktionieren kann. Jeder Arbeiterthread braucht seinen eigenen Puffer, was am leichtesten mit
strdup(3) erreicht werden kann. (-1.0)
endsnippet

context "c() and mach()"
snippet mach_detach_worker "Arbeiterthreads nicht detached"
Die Arbeiterthreads sollen mittels pthread_detach(3) detached werden, damit die Ressourcen beim
Beenden automatisch freigegeben werden. (-1.0)
endsnippet

context "c() and mach()"
snippet mach_flag_constants "magische Werte fuer Flags"
Hier werden einfach direkt Zahlen fuer verschiedene Situationen in den "flags" verwendet. Das
funktioniert natuerlich, aber ist sehr fehleranfaellig: es ist leicht, versehentlich an einer
Stelle eine falsche Zahl zu verwenden. Ein guter Weg, das zu umgehen, ist mithilfe einer enum, z.B.
"enum Flags { RUNNING, COMPLETED, POISON };".
endsnippet

context "c() and mach()"
snippet mach_flag_define_macros "Makros fuer Flags"
Makros sind ein guter Weg hierfuer. Noch besser (in meinen Augen) waere aber eine enum. ;)
endsnippet

context "c() and mach()"
snippet mach_join_detached_thread "pthread_join() auf detached Thread"
Wenn ein Thread mittels pthread_detach(3) detached wurde, kann auf diesen nicht mehr mit
pthread_join(3) gewartet werden. Hier braucht man Semaphoren zum Warten. (-1.0)
endsnippet

context "c() and mach()"
snippet mach_output_thread_join "nicht auf Ausgabethread gewartet"
Es muss noch gewartet werden, bis der Ausgabethread sich beendet hat, damit sicher alle Ausgaben
rausgeschrieben werden. Das geht am leichtesten mit pthread_join(3). (-1.0)
endsnippet

context "c() and mach()"
snippet mach_run_cmd_error "Fehler beim Ausfuehren nicht ignoriert"
Laut Aufgabenstellung sollen Fehler beim Ausfuehren (mit "run_cmd") vollstaendig ignoriert werden.
(-1.0)
endsnippet

context "c() and mach()"
snippet mach_slow_critical "langsame Funktion in kritischem Abschnitt"
Langsame Funktionen (wie ${1:`!p snip.rv = var()`(3)}) duerfen laut Aufgabenstellung nicht in
kritischen Abschnitten ausgefuehrt werden. (-1.0)
endsnippet

# queue.c {{{
context "c() and mach('queue.c')"
snippet mach_early_lock "fruehes locken durch P() in queue_put()"
Es waere besser, das erst zu machen, wenn es wirklich notwendig ist, d.h. erst vor dem Zugriff auf
"${1:head}". malloc(3) ist vergleichsweise langsam, deswegen sollte das eher nicht Teil des
kritischen Abschnitts werden.
endsnippet

context "c() and mach('queue.c')"
snippet mach_free "Belegte Ressourcen im Fehlerfall nicht freigegeben"
"If an error occurs during initialization, all already allocated resources must be freed before
returning an error." (-1.0)
endsnippet

context "c() and mach('queue.c')"
snippet mach_return_no_unlock "kein unlocken des Mutex in fruehzeitigem return"
Hier wird die Funktion verlassen, aber das Mutex "${1:lock}" wird nicht (mit V()) freigegeben; die
queue kann danach quasi nicht mehr verwendet werden. (-1.0)
endsnippet
# }}}
# }}}

# creeper {{{
context "c() and creeper()"
snippet creeper_basename "basename() auf Original-String"
basename(3) kann den Inhalt des uebergebenen Strings veraendern. Daher muss man eine Kopie anlegen,
wenn man den Inhalt danach nochmal benutzen will. (-1.0)
endsnippet

context "c() and creeper()"
snippet creeper_dir_assumption "Annahme, dass etwas ein Verzeichnis ist"
Man darf nicht davon ausgehen, dass das hier ein Verzeichnis ist, da auf der Kommandozeile auch
regulaere Dateien uebergeben werden duerfen. Man muss also zuerst pruefen, um was fuer eine Art von
Verzeichniseintrag es sich hierbei handelt. (-1.0)
endsnippet

context "c() and creeper()"
snippet creeper_exit "exit() in Rekursion"
Hier zu sterben ist keine gute Idee, da Fehler wie z.B. "EACCES" (fehlende Berechtigung) haeufiger
auftreten werden. Stattdessen einfach mit dem naechsten Verzeichniseintrag weiterzumachen ist
besser. (-0.5)
endsnippet

context "c() and creeper()"
snippet creeper_fnm_period "kein FNM_PERIOD"
Die Pruefung soll gemaess Shell-Wildcards erfolgen. Damit fuehrende Punkte in "${1:pattern}"
explizit angegeben werden muessen (so wie es bei Shell-Wildcards ist, siehe Manpage glob(7)), muss
"FNM_PERIOD" in den Flags enthalten sein. (-0.5)
endsnippet

context "c() and creeper()"
snippet creeper_lstat_stat "stat() statt lstat() verwendet"
Hier muss lstat(2) verwendet werden, da laut Aufgabenstellung symbolische Links ignoriert werden
sollen. Um das zu erreichen, muss man bei einem symbolischen Link Informationen ueber den Link
selbst bekommen, und nicht ueber das, worauf der Link verweist. Das geht nur mit lstat(2), da
stat(2) den symbolischen Link quasi dereferenziert (siehe Manpage). (-1.0)
endsnippet

context "c() and creeper()"
snippet creeper_no_arguments "nicht auf keine Argumente geprueft"
Im Falle von "getNumberOfArguments() == 0" ist es sinnvoll, den Benutzer auf die korrekte
Verwendung hinzuweisen, damit er weiss, wie die creeper zu verwenden ist. Zur Inspiration kann man
z.B. mal die Referenzimplementierung ohne jegliche Argumente aufrufen. ;)
endsnippet

context "c() and creeper()"
snippet creeper_skip_dot ". und .. nicht uebersprungen"
Die Verzeichniseintraege "." und ".." muessen uebersprungen werden, da es sonst zu einer
Endlosrekursion kommt. (-1.0)
endsnippet

context "c() and creeper()"
snippet creeper_type_check "type-Option nicht geprueft"
Es ist generell immer eine gute Idee, Benutzereingaben zu pruefen (falls moeglich). Da fuer die
"type"-Option nur zwei gueltige Werte ("d" und "f") existieren, ist es sehr sinnvoll, genau darauf
zu pruefen. Falls der Benutzer etwas anderes uebergibt, kann man ihm das dann mit einer
Fehlermeldung mitteilen. :)
endsnippet
# }}}



# snail {{{
context "c() and snail()"
snippet snail_ai_addrconfig "kein AI_ADDRCONFIG in Flags"
Wenn in "ai_flags" das "AI_ADDRCONFIG" fehlt, kann es passieren, dass im spaeteren Verlauf eine
Verbindungsart gewaehlt wird, die weder vom Kernel noch der Hardware unterstuetzt wird; der Fehler
wird erst beim Aufruf von socket(2) geschehen. Da eine entsprechende Fehlermeldung den Nutzer nur
unnoetig verunsichert, ist es hier angebracht, mit AI_ADDRCONFIG nach unterstuetzten Verbindungen
zu filtern.
endsnippet

context "c() and snail()"
snippet snail_dot_missing_CRLF "Zeilenumbruch vor '.' fehlt"
Die Benutzereingabe muss nicht zwingend mit '\n' (bzw. "\r\n") enden, d.h. hier fehlt eventuell ein
Zeilenumbruch vor dem '.'. Sonst kann der Server nicht erkennen, dass die Mail vorbei ist. (-1.0)
endsnippet

context "c() and snail()"
snippet snail_doubled_CR "doppeltes \r bei Benutzereingabe"
Die Eingabe kann bereits ein '\r' enthalten (je nach Benutzersystem). In diesem Fall wird hier
faelschlicherweise ein zusaetzliches '\r' eingefuegt. Ist letztendlich wohl nicht schlimm, aber
vermutlich nicht so beabsichtigt.
endsnippet

context "c() and snail()"
snippet snail_eai_system "keine gesonderte Behandlung von EAI_SYSTEM"
Bei dem Rueckgabewert EAI_SYSTEM ist die errno(3) gesetzt. Damit ist eine Ausgabe mithilfe von
perror(3) sinnvoller.
endsnippet

context "c() and snail()"
snippet snail_expected_status_code "erwarteter Status-Code als int"
Wenn man den erwarteten Status-Code direkt als String uebergibt, spart man sich die Umwandlung
zwischen String und Zahl. Dann kann man den eingelesenen Status-Code direkt mittels strcmp(3)
vergleichen. ;)
endsnippet

context "c() and snail()"
snippet snail_fflush_often "fflush() unnoetig oft"
Hier ist es nicht noetig, nach jede${1|r Zeile,m Zeichen|} fflush(3) aufzurufen. Man muss ja nur
flushen, wenn man eine Antwort vom Server erwartet, was hier (eine Weile lang) nicht der Fall
ist.
endsnippet

context "c() and snail()"
snippet snail_fqdn "FQDN nicht bestimmt"
Hier muss der FQDN des Clients mit einem DNS-Lookup bestimmt werden. Wie genau das geht, steht in
einem Hinweis in der Aufgabenstellung. (-3.0)
endsnippet

context "c() and snail()"
snippet snail_from_full_name "voller Name im From-Feld fehlt"
Hier soll noch der volle Name des Benutzers gesendet werden, welcher in der passwd-Struktur steht
(siehe letzter Hinweis in der Aufgabenstellung). (-2.0)
endsnippet

context "c() and snail()"
snippet snail_gethostname_length "namelen bei gethostname() anders als bei Definition"
Hier muss der gleiche Wert verwendet werden wie oben bei der Definition von "${1:hostname}". (-0.5)
endsnippet

context "c() and snail()"
snippet snail_getpwuid "in Speicher von getpwuid() geschrieben"
Es ist nicht erlaubt, in den von getpwuid(3) zurueckgegebenen Speicher zu schreiben. Stattdessen
muss eine Kopie der Daten angelegt werden, wenn diese veraendert werden sollen.
"The application shall not modify the structure to which the return value points, nor any storage
areas pointed to by pointers within the structure." (Manpage getpwuid(3p)) (-1.0)
endsnippet

context "c() and snail()"
snippet snail_hints_unneeded_fields "unnoetige Felder fuer FQDN-Lookup gesetzt"
Fuer den FQDN-Lookup braucht man nur das AI_CANONNAME in den Flags. Alle anderen Werte sind dafuer
ja irrelevant.
endsnippet

context "c() and snail()"
snippet snail_hints_canonname_written "hints.ai_canonname wird beschrieben"
"ai_canonname" wird von getaddrinfo(2) gesetzt; dort wird also quasi Information zurueckgegeben.
Das zu setzen ist also sinnlos.
endsnippet

context "c() and snail()"
snippet snail_last_answer "letzte Serverantwort nicht ausgegeben"
Im Fehlerfall soll die letzte Antwort des Servers (auf stderr) ausgegeben werden. (-1.0)
endsnippet

context "c() and snail()"
snippet snail_length_response "Annahme ueber Laenge der Antwort getroffen"
Es duerfen keine Annahmen ueber die maximale Laenge einer Antwortzeile, die vom Server kommt,
getroffen werden. Der einfachste Weg, mit solchen Zeilen unbekannter Laenge umzugehen, ist
ein zeichenweises Vorgehen, z.B. mit fgetc(3). (-2.0)
endsnippet

context "c() and snail()"
snippet snail_line_endings "Zeilen enden nicht auf \r\n"
Alle an den Server uebertragenen Zeilen muessen auf "\r\n" (DOS-Format) enden. (-1.0)
endsnippet

context "c() and snail()"
snippet snail_mailbody "Mail-Body am Anfang eingelesen"
Es ist ziemlich schade, wenn der Benutzer seine gesamte Mail eintippt, nur damit dann z.B. beim
Herstellen der Verbindung ein Fehler auftritt, der zum Programmabbruch fuehrt. Ein anderer Aufbau
waere hier schlauer gewesen. Ausserdem muss man sich den Mailinhalt dann nicht zwischenspeichern,
sondern kann ihn direkt an den Server uebertragen, was den Code deutlich einfacher macht. ;)
endsnippet

context "c() and snail()"
snippet snail_socket_exit "exit() bei socket()"
In diesem Fall sollte das Programm nicht beendet werden. Der Punkt der for-Schleife ist ja, dass
verschiedene Moeglichkeiten (d.h. verschiedene Arten von Sockets) ausprobiert werden; wenn also
eine davon nicht funktioniert, soll hier einfach die naechste versucht werden. Nur wenn keine
einzige Moeglichkeit geklappt hat, muss das Programm tatsaechlich beendet werden, weil natuerlich
nicht sinnvoll weiter gemacht werden kann. (-1.0)
endsnippet

context "c() and snail()"
snippet snail_space_statuscode "nicht auf Leerzeichen nach Statuscode geprueft"
Es waere gut, noch zu pruefen, ob nach dem dreistelligen Statuscode auch ein Leerzeichen kommt.
Sonst waere es ja theoretisch moeglich, dass es ein vierstelliger Statuscode ist; solche sind zwar
nicht definiert, aber das Programm wird dadurch etwas robuster. ;)
endsnippet
# }}}

# sister {{{
# sister.c {{{
context "c() and sister('sister.c')"
snippet sister_accept_exit "exit() bei accept"
In diesem Fall sollte das Programm nicht beendet werden, nur weil die Verbindung nicht hergestellt
werden konnte. Der Server kann in dieser Situation durchaus weiter laufen, denn mindestens die
folgenden Fehler sind keine Schwerwiegenden und sollten ein Retry zur Folge haben:
"For reliable operation the application should detect the network errors defined for the protocol
after accept() and treat them like EAGAIN by retrying. In the case of TCP/IP, these are ENETDOWN,
EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH." (Manpage
accept(2))
Die Fehlermeldung kann ja trotzdem mit perror() ausgeben werden. (-0.5)
endsnippet

context "c() and sister('sister.c')"
snippet sister_htons "kein htons() verwendet"
Der Port muss noch mit htons(3) in die Netzwerk-Byteorder gebracht werden. (-0.5)
endsnippet

context "c() and sister('sister.c')"
snippet sister_port_range "kein Check fuer Wertebereich vom Port"
Hier wird der Port ${1|implizit,explizit|} auf einen "uint16_t" gecastet. Wenn der vom Benutzer
eingegebene Wert nicht im Wertebereich eines "uint16_t"s liegt, wird der Wert einfach
abgeschnitten. Damit das nicht passiert, muss vorher explizit geprueft werden, ob der vom
Benutzer gegebene Wert im Wertebereich liegt. (-0.5)
endsnippet

context "c() and sister('sister.c')"
snippet sister_uint16_max_const "Konstante anstatt von UINT16_MAX verwendet"
Hier waere es wohl besser, die Konstante "UINT16_MAX" zu verwenden. Das ist ja der Typ, der am Ende
von htons(3) erwartet wird.
endsnippet

context "c() and sister('sister.c')"
snippet sister_wwwpath_module "wwwpath im falschen Modul geprueft"
Der wwwpath ist fuer dieses Modul nicht relevant. Das sollte eigentlich im request-Modul geprueft
werden.
endsnippet
# }}}

# connection-fork.c {{{
context "c() and sister('connection-fork.c')"
snippet sister_child_return "return im Kind"
Im Kind darf auf keinen Fall returnt werden: der Kind-Prozess muss sich mittels exit(3) beenden.
Sonst kehrt er in die accept(2)-Schleife in "main" zurueck, und man hat auf einmal mehrere
Prozesse, die auf dem gleichen Socket auf Anfragen warten. (-1.0)
endsnippet

context "c() and sister('connection-fork.c')"
snippet sister_fork_exit "exit() bei fork()"
fork(2) kann auch aufgrund von Ressourcen-Knappheit scheitern, was im spaeteren Verlauf wieder
gelingen kann. Zum Beispiel kann es sein, dass gerade sehr viele Kinder existieren, und erst
gewartet werden muss, bis sich eins von ihnen beendet hat.
Deshalb sollte hier im Fehlerfall das Programm nicht beendet werden. (-0.5)
endsnippet

context "c() and sister('connection-fork.c')"
snippet sister_clientSock_close "kein close() auf clientSock im Elternprozess"
Im Elternprozess muss noch "clientSock" geschlossen werden, da dieser beim fork(2) auch dupliziert
wurde (siehe auch Foliensatz zur rush, 3.5). Damit am Ende keine Ressourcen geleakt werden, muss er
hier geschlossen werden, sobald er nicht mehr gebraucht wird (was eigentlich sofort ist). Das steht
auch indirekt in connection.h. (-0.5)
endsnippet

context "c() and sister('connection-fork.c')"
snippet sister_listenSock_close "kein close() auf listenSock im Kindprozess"
Im Kind muss noch "listenSock" geschlossen werden, da dieser beim fork(2) auch dupliziert wurde
(siehe auch Foliensatz zur rush, 3.5). Das steht uebrigens auch in connection.h explizit drin. ;)
(-0.5)
endsnippet
# }}}

# request-http.c {{{
context "c() and sister('request-http.c')"
snippet sister_exit "exit() statt return"
Hier exit(3) aufzurufen ist keine gute Idee, da sich dadurch (wenn das connection-Modul ohne die
Erzeugung von Kindprozessen implementiert ist) womoeglich der ganze Server beendet. Und die Module
sollen ja unabhaengig voneinander korrekt sein. (-1.0)
endsnippet

context "c() and (sister('request-http.c') or mother('request-httpx.c'))"
snippet sister_mother_checkpath "checkPath() auf falschen Pfad angewandt"
"checkPath" muss auf den Anfragepfad (also direkt der Pfad aus der HTTP-GET-Anfrage) aufgerufen
werden. (-1.0)
endsnippet

context "c() and (sister('request-http.c') or mother('request-httpx.c'))"
snippet sister_mother_fgets_file "fgets() zum Senden der Datei genutzt"
fgets(3) kann hier nicht verwendet werden, da prinzipiell "beliebige" Dateien angefordert werden
koennten, z.B. auch Bilder. Und Bilder sind keine Textdateien (fuer welche fgets(3) funktionieren
wuerde), sondern letztendlich Binaerdateien. Wenn in einem Bild also ein Byte mit dem Wert 0
vorkommt, wird das quasi als '\0' interpretiert, und die Datei wird nicht vollstaendig gesendet.
Hier muss also zeichenweise mit z.B. fgetc(3) gearbeitet werden. (-1.0)
endsnippet

context "c() and (sister('request-http.c') or mother('request-httpx.c'))"
snippet sister_mother_line_endings "nicht \n und \r\n unterstuetzt"
Laut Aufgabenstellung darf die Anfragezeile sowohl mit "\n", als auch "\r\n" enden. Dies wird hier
nicht unterstuetzt. (-1.0)
endsnippet

context "c() and (sister('request-http.c') or mother('request-httpx.c'))"
snippet sister_mother_multiple_answers "mehrere http*()-Aufrufe"
Es wurde bereits eine Antwort mit "${2:httpOk}" gesendet. Hier nochmal eine (andere) Antwort zu
schicken ist schlecht, da der Browser das nicht erwartet und dementsprechend kaputt anzeigt.
${1:(-0.5)}
endsnippet

context "c() and (sister('request-http.c') or mother('request-httpx.c'))"
snippet sister_mother_no_answer "keine Antwort an Client"
In diesem Fall wird dem Client keine Antwort gesendet; es sollte aber eine (passende) Fehlermeldung
gesendet werden. (-0.5)
endsnippet

context "c() and (sister('request-http.c') or mother('request-httpx.c'))"
snippet sister_mother_strtok_end "nicht auf zusaetzliche Zeichen am Ende der Anfrage geprueft"
Es waere cool, hier mit einem weiteren strtok(3)-Aufruf zu pruefen, ob danach noch mehr in der
Anfragezeile steht. Das ist moeglich, da als Delimiter auch '\r' verwendet wird, d.h. eine Zeile
der Form "GET /index.html HTTP/1.1\rhallo\n" wird hier als gueltig geparst, obwohl sie ja
eigentlich ungueltig ist.
endsnippet

context "c() and (sister('request-http.c') or mother('request-httpx.c'))"
snippet sister_mother_token_null_check "Token nicht auf NULL geprueft vor Verwendung"
Die Tokens muessen noch auf NULL geprueft werden, bevor sie (z.B. mit strcmp(3)) verwendet werden.
Sonst kann das schnell zu einem Segmentation Fault fuehren. (-0.5)
endsnippet

context "c() and sister('request-http.c')"
snippet sister_regular_file "nicht auf regulaere Datei geprueft"
Es sollen lediglich regulaere Dateien ausgeliefert werden. (-1.0)
endsnippet

context "c() and sister('request-http.c')"
snippet sister_wwwpath_length "wwwpath Laenge nicht geprueft"
Es waere schoen, noch zu pruefen, ob der wwwpath ein leerer String ist, was dann mit einer
Fehlermeldung abgehandelt werden kann.
endsnippet
# }}}
# }}}

# rush {{{
context "c() and rush()"
snippet rush_block_all_signals "unnoetig alle Signale mit sigfillset() blockiert"
Hier alle Signale zu blockieren ist overkill. Es waere schoener, sich hier zu ueberlegen, welche(s)
Signal(e) man genau blockieren muss, und dann genau diese (und nicht mehr) blockiert.
endsnippet

context "c() and rush()"
snippet rush_fork_sigchld_unblocked "SIGCHLD vor fork() nicht blockiert"
Vor dem fork(2) muss SIGCHLD blockiert werden. Falls sich der Kindprozess, der hier erzeugt wird,
beendet, bevor der Elternprozess diesen in die plist eintragen kann, wird hier naemlich ein SIGCHLD
zugestellt. Das geht dann im Signalhandler kaputt, da dort ja erwartet wird, dass der Kindprozess
in der plist steht. (-2.0)
endsnippet

context "c() and rush()"
snippet rush_kill_exit "exit() bei kill()"
Hier lieber nicht sterben, denn: "ESRCH  The process or process group does not exist. Note that an
existing process might be a zombie, a process that has terminated execution, but has not yet been
wait(2)ed for." (Manpage kill(2)) Und das ist moeglich, da hier SIGCHLD blockiert ist, und deswegen
der Kindprozess, der gerade getoetet werden soll, noch ein Zombie sein kann. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_nuke_kill_non_child "kill() moeglicherweise fuer nicht-Kindprozess"
Es muss noch geprueft werden, ob der zu toetende Prozess ueberhaupt ein eigener Kindprozess ist.
Dafuer muss man in der plist mittels "plistGet" nachschauen. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_nuke_plist_unsynchronized "ungeschuetzter Zugriff auf plist in nuke()"
Da hier auf der plist gearbeitet wird, muss SIGCHLD blockiert sein. Sonst kann es passieren, dass
die selbststaendige Terminierung eines zu toetenden Kindprozesses etwas kaputt macht, da in dem
Fall ja unsynchronisiert auf die plist zugegriffen werden wuerde. (-1.0)
Auch kann es passieren, dass sich der Kindprozess beendet, und die PID wiederverwendet wird - dann
wird ein (vermutlich) komplett anderer Prozess faelschlicherweise getoetet. Es muss also bis nach
dem sleep(3) verhindert werden, dass SIGCHLD zugestellt wird. (-1.0)
endsnippet

context "c() and rush()"
snippet rush_open_flags "open() flags falsch"
Hier muessen die korrekten "flags" angegeben werden; oder einfacher: man nutzt creat(2).
(-0.5)
endsnippet

context "c() and rush()"
snippet rush_open_mode "open() mode falsch"
Laut Aufgabenstellung soll die erstellte Datei Leserechte fuer alle und Schreibrechte fuer den
Besitzer haben. Dafuer kann man eine Veroderung der in der Manpage angegeben Makros nutzen:
"S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH". (-0.5)
endsnippet

context "c() and rush()"
snippet rush_plist_unsynchronized_access "ungeschuetzter Zugriff auf plist"
Um hier auf der plist zu arbeiten, muss sichergestellt werden, dass der Signalhandler nicht
gleichzeitig auf die plist zugreift, da sonst der interne Zustand kaputt gehen kann. Um das zu
erreichen, muss hier voruebergehend die Zustellung von SIGCHLD blockiert werden. (-2.0)
endsnippet

context "c() and rush()"
snippet rush_redirection_close "close() fehlt bei Ein-/Ausgabeumleitung"
Der Dateideskriptor "${1:`!p snip.rv = var()`}" muss hier noch geschlossen werden. Nach dem dup2(2)
existieren erstmal zwei Dateideskriptoren, die auf die gleiche Datei zeigen ("$1" und
"STDIN_FILENO"); dementsprechend muss hier close(2) verwendet werden. (-1.0)
endsnippet

context "c() and rush()"
snippet rush_redirection_parent "Ein-/Ausgabeumleitung im Elternprozess"
Die Umleitung der Ein-/Ausgabe im Elternprozess zu machen ergibt keinen Sinn. Warum nicht einfach
im Kindprozess machen, wo es relevant ist (weil dort der Befehl tatsaechlich ausgefuehrt wird)?
(-1.0)
endsnippet

context "c() and rush()"
snippet rush_sa_mask "sa_mask nicht gesetzt bei SIGCHLD-Handler"
Hier muss noch der "sa_mask"-Member mittels sigemptyset(3) initialisiert werden. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_sa_restart "SA_RESTART fehlt bei Signalhandler"
Hier muss "SA_RESTART" in den Flags angegeben werden, damit Systemaufrufe, die von einem Signal
unterbrochen wurden, einfach neugestartet werden. Alternativ muessten bei allen Systemaufrufen der
Fehler "EINTR" entsprechend behandelt werden, was aber sehr viel komplizierter ist. ;) (-1.0)
endsnippet

context "c() and rush()"
snippet rush_signal_handler_errno "errno im Signalhandler nicht gesichert"
Im Signalhandler muss die errno(3) am Anfang gesichert und am Ende wiederhergestellt werden, wenn
sie durch den Signalhandler veraendert werden kann. In diesem Fall kann die errno von waitpid(2)
gesetzt werden. (-0.5)
endsnippet

context "c() and rush()"
snippet rush_signal_handler_loop "keine Schleife im Signalhandler"
Wenn sich mehrere Kindprozesse gleichzeitig beenden, wird zwar prinzipiell auch mehrmals das
SIGCHLD zugestellt, aber es wird nur einmal zwischengespeichert - d.h. der Signalhandler wird auch
nur einmal aufgerufen. Das liegt daran, dass die Signale gleichzeitig kommen koennen, und der
Elternprozess dann nicht mit dem Behandeln "hinterherkommt". Deswegen muss man im Signalhandler
davon ausgehen, dass man nicht ein einzelnes Signal behandelt, sondern zwischen null und
"unendlich" viele: man braucht hier also eine Schleife, um waitpid(2) wiederholt auszufuehren.
(-1.0)
endsnippet

context "c() and rush()"
snippet rush_signal_handler_stdio "Ausgaben im Signalhandler mit stdio"
In einem Signalhandler duerfen nur async-signal-safe Funktionen aufgerufen werden; siehe Manpage
signal-safety(7). ${1:`!p snip.rv = var()`}(3) ist keine solche Funktion. (-1.0)
endsnippet

context "c() and rush()"
snippet rush_sigsuspend_background "sigsuspend() wartet auf Hintergrundprozesse"
Hier muss sichergestellt werden, dass sigsuspend(3) nicht durch das Beenden eines
Hintergrundprozesses zurueckkehrt: hier soll ja auf den eben gestarteten Vordergrundprozess
gewartet werden. Um das zu realisieren, kann eine Variable aehnlich wie im Foliensatz unter 3.2
verwendet werden. (-2.0)
endsnippet

context "c() and rush()"
snippet rush_sleep_signals_unblocked "Signale waehrend sleep() nicht blockiert"
Waehrend sleep(3) ausgefuehrt wird, muss sichergestellt sein, dass "kein Signal dafuer sorgen kann,
dass sleep(3) vorzeitig zurueckkehrt" (siehe Aufgabenstellung). (-1.0)
endsnippet
# }}}

# jbuffer {{{
context "c() and jbuffer()"
snippet jbuffer_errno_set_to_zero "errno wird auf 0 gesetzt"
Die errno darf von Bibliotheksfunktionen niemals auf den Wert 0 gesetzt werden. POSIX gibt zwar nur
die Garantie, dass keine POSIX-Funktion die errno auf 0 setzt, aber im C11-Standard heisst es:
"[errno] is never set to zero by any library function". (C11 7.5 Abs. 3) Und genau das kann hier
passieren, wenn die aufgerufene Funktion erfolgreich war.
endsnippet

context "c() and jbuffer()"
snippet jbuffer_NULL_check "Vergleich mit NULL fehlt fuer Argument"
"`!p snip.rv = var()`" muss hier noch auf NULL geprueft werden, in welchem Fall die Funktion
gar nichts machen soll. (-0.5)
endsnippet

# jbuffer.c {{{
context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_atomic "Leseindex nicht atomic"
Der Leseindex muss als atomic deklariert werden (z.B. mittels "_Atomic"), da dieser mit
atomic-Funktionen (z.B. dem CAS) verwendet wird. (-0.5)
endsnippet

context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_atomic_unneeded "unnoetiges atomic"
Das muss nicht atomic sein. Dann wird der restliche Code etwas schoener, da der Wert dann ja direkt
(d.h. ohne atomic-Funktionen) verwendet werden darf. ;)
endsnippet

context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_CAS_r_late_read "Leseindex bei CAS zu spaet ausgelesen"
Man darf sich hier auf keinen Fall den Wert vom Leseindex ("bb->${1:read}") erst bei dem CAS holen:
die Idee hinter der Schleife ist, dass man sich den Wert holt, Berechnungen durchfuehrt, und am
Ende vergleicht, ob noch derselbe Wert drin steht, wie zuvor. Dadurch soll ja erkannt werden, ob
ein anderer Thread in der Zwischenzeit "bbGet" aufgerufen hat, in welchem Fall das ganze dann
wiederholt werden muss. Hier wird der Wert zwei mal direkt nacheinander ausgelesen, und diese
miteinander verglichen, wobei diese in den allermeisten Faellen identisch sind. Deswegen wird hier
nicht korrekt erkannt, ob ein anderer Thread dazwischen kam, und das CAS ist hier kaputt. (-1.0)
endsnippet

context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_CAS_date_late_read "Datum erst nach CAS ausgelesen"
Das Datum muss zwingend innerhalb der CAS-Schleife entnommen werden. Sonst kann es (vor allem bei
einem vollen Ringpuffer) vorkommen, dass zwischen dem CAS und dem Entnehmen des Datums ein anderer
Thread den Wert ueberschreibt. Ein ausfuehrliches Beispiel dazu gibt es auch im Foliensatz, der in
der Besprechungsuebung gezeigt wird (Kapitel 7.1). (-1.0)
endsnippet

context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_fam "kein FAM verwendet"
Hier kann man auch einen Flexible Array Member (siehe halde) verwenden. ;)
endsnippet

context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_free "Belegte Ressourcen im Fehlerfall nicht freigegeben"
"If an error occurs during the initialization, the implementation frees all resources already
allocated by then." (-1.0)
endsnippet

context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_int "int statt size_t fuer Leseindex (und Kopie davon)"
"`!p snip.rv = var()`" und der Leseindex ("bb->${1:read}") sind "int"s. Das ist problematisch, da
"`!p snip.rv = var()` + 1" bereits ausserhalb des gueltigen Wertebereichs (d.h. groesser als
"INT_MAX") sein kann - naemlich genau dann, wenn "bb->${2:size}" exakt "INT_MAX" betraegt. Um
dieses Problem zu loesen, muessen sowohl "`!p snip.rv = var()`" als auch "bb->$1" vom Typ "size_t"
sein. (-1.0)
endsnippet

context "c() and jbuffer('jbuffer.c')"
snippet jbuffer_size_int_max "size nicht auf > INT_MAX geprueft"
Wenn "`!p snip.rv = var()`" groesser als "INT_MAX" ist, dann wird in der Semaphoren-Implementierung
der Wert abgeschnitten, da "semCreate" ja nur einen "int" als Parameter nimmt. Eine Abfrage
diesbezueglich sollte immer dann erfolgen, wenn man in einen kleineren Datentypen umwandelt, was
hier implizit passiert. (-0.5)
endsnippet
# }}}

# sem.c {{{
context "c() and jbuffer('sem.c')"
snippet jbuffer_free "Belegte Ressourcen im Fehlerfall nicht freigegeben"
"If an error occurs during the initialization, the implementation frees all resources already
allocated by then and sets @c errno to an appropriate value." (-1.0)
endsnippet

context "c() and jbuffer('sem.c')"
snippet jbuffer_negative_counter "Negativer Counter nicht beruecksichtigt"
Eine Semaphore kann auch mit einem negativen Wert initialisiert werden, um Signalisierung zu
implementieren. Das wird hier nicht beruecksichtigt. (-1.0)
endsnippet

context "c() and jbuffer('sem.c')"
snippet jbuffer_p_null_return "return bei NULL-Argument in P() bzw. V()"
Das ist nicht so spezifiziert, und in vielen Faellen ist hier ein Segmentation Fault wahrscheinlich
wirklich sinnvoller: dadurch merkt der Benutzer immerhin, dass er etwas falsch macht. So ein
stilles Fehlschlagen bzw. Nichtstun ist nicht so schlau, da ${1:P}() ja erwartungsgemaess auch
blockieren kann.
endsnippet

context "c() and jbuffer('sem.c')"
snippet jbuffer_return_error "return in Fehlerfall"
Wenn `!p snip.rv = var()`(3) fehlschlaegt, haelt man trotzdem noch das Mutex. Prinzipiell ist es
also sinnvoller, das vor einem Zurueckkehren noch freizugeben. Allerdings ist wahrscheinlich eh
schon alles kaputt, wenn `!p snip.rv = var()`(3) fehlschlaegt, weswegen das auch nicht gerade
eine perfekte Loesung ist. ;)
endsnippet

context "c() and jbuffer('sem.c')"
snippet jbuffer_signal_after_unlock "signal()/broadcast() ausserhalb des kritischen Abschnitts"
Das `!p snip.rv = var()`(3) muss noch innerhalb des kritischen Abschnitts erfolgen, da man sonst
Probleme bzgl. Race Conditions bekommen kann. "Thus, if all threads always acquire the mutex before
signaling the condition, this guarantees that the condition cannot be signaled (and thus ignored)
between the time a thread locks the mutex and the time it waits on the condition variable."
(Manpage `!p snip.rv = var()`(3)) (-1.0)
endsnippet
# }}}
# }}}

# mother {{{
# connection-mt.c {{{
context "c() and mother('connection-mt.c')"
snippet mother_cloexec_clientSock "clientSock FD_CLOEXEC nicht gesetzt"
"clientSock" muss noch mit dem Close-on-Exec-Flag versehen werden, damit dieser nicht an
aufgerufene Perl-Skripte vererbt werden. Das geht mittels fcntl(2). (-1.0)
endsnippet

context "c() and mother('connection-mt.c')"
snippet mother_dup_cloexec "Kein FD_CLOEXEC nach dup()"
Unmittelbar nach dem dup(2) muss der neue Deskriptor ebenfalls mit dem Close-on-Exec-Flag versehen
werden. Dies geschieht am besten, indem man anstelle von dup(2) einfach fcntl(2) mit dem Kommando
"F_DUPFD_CLOEXEC" aufruft, um das Duplizieren und Setzen des FD_CLOEXEC-Bits in einem (fuer den
Prozess) atomaren Schritt auszufuehren. (-1.0)
endsnippet

context "c() and mother('connection-mt.c')"
snippet mother_exit "unnoetiges exit()"
Nur weil das fehlschlaegt, soll sich nicht gleich der ganze Thread beenden: das hier ist ein
Server, d.h. man will nur im absoluten Ausnahmefall das Programm beenden. In diesem Fall aber gab
es nur ein Problem bei der aktuellen Anfrage, der Server kann jedoch noch weiterlaufen. Deswegen
sollte man hier lediglich eine Fehlermeldung ausgeben und bereits belegte Ressourcen wieder
freigeben. (-1.0)
endsnippet

context "c() and mother('connection-mt.c')"
snippet mother_late_cloexec_clientSock "clientSock FD_CLOEXEC zu spaet gesetzt"
Es ist zwingend notwendig, das Close-on-Exec-Flag auf "clientSock" bereits *vor* dem Hinzufuegen
zum Puffer vorzunehmen. Sonst ist es bei einem sehr grossen Puffer, schnell hintereinander
eintreffender Anfragen und wenig Threads mit steigender Wahrscheinlichkeit moeglich, dass ein
anderer Thread ein exec(3) ausfuehrt, bevor dieser Dateideskriptor mit dem Flag versehen wird.
Dadurch dass sich alle Threads einen Adressraum teilen, koennen auch ueber Threads hinweg die
Dateideskriptoren an Kinder vererbt werden. Das ist ein Problem das sich nicht vollends loesen
laesst, aber den Dateideskriptor hier womoeglich lange ungeschuetzt in der Queue zu lassen ist
keine gute Idee. (-0.5)
endsnippet

context "c() and mother('connection-mt.c')"
snippet mother_race_dup_cloexec "Race Condition durch dup() + fcntl()"
Hier existiert eine kleine Race Condition: zwischen dem dup(2) und dem fcntl(2) ist das
Close-on-Exec-Flag nicht gesetzt. Wenn also genau hier ein fork(2) in einem anderen Thread
aufgerufen wird, wird der Dateideskriptor hier auch nach dem exec(2) offen bleiben. Deswegen ist es
am besten, hier einfach fnctl(2) mit dem Kommando "F_DUPFD_CLOEXEC" aufruft, um das Duplizieren und
Setzen des FD_CLOEXEC-Bits in einem (fuer den Prozess) atomaren Schritt auszufuehren.
endsnippet
# }}}

# request-httpx.c {{{
context "c() and mother('request-httpx.c')"
snippet mother_directory_dot "Verzeichniseintraege mit Punkt nicht gefiltert"
Es sollen nur die Verzeichniseintraege ausgegeben werden, deren Name nicht mit einem '.' beginnt.
(-1.0)
endsnippet

context "c() and mother('request-httpx.c')"
snippet mother_file_cloexec "FD_CLOEXEC nicht bei geoeffneten Dateien gesetzt"
Es waere schoen, wenn auch die geoeffneten Dateien das Close-on-Exec-Flag bekommen wuerden, selbst
wenn es in der Aufgabenstellung nicht explizit gefordert ist. Damit dies ohne Wettlaufsituation
gelingt, muss man zunaechst open(2) mit O_CLOEXEC aufrufen. Wenn man anschliessend die auf FILE*
arbeitenden Funktionen (wie z.B. fgets(3)) nutzen moechte, muss noch ein fdopen(3) verwendet
werden.
endsnippet

context "c() and mother('request-httpx.c')"
snippet mother_index_html_file "kein Check ob index.html regulaere Datei ist"
"index.html" soll nur ausgeliefert werden, wenn es eine Datei und kein Verzeichnis ist. Wenn
es sich um ein Verzeichnis handelt, soll stattdessen einfach das angeforderte Verzeichnis gelistet
werden. (-0.5)
endsnippet

context "c() and mother('request-httpx.c')"
snippet mother_perl_length "bei Perl-Skript-Namen ueber Anfang hinausgelesen"
Beim Pruefen, ob der Dateiname auf ".pl" endet, muss sichergestellt werden, dass nicht links ueber
den Anfang des Strings hinausgelesen wird. Wenn z.B. der Name einer Datei nur aus einem einzelnen
Buchstaben besteht, tritt hier genau dieses Problem auf. (-0.5)
endsnippet

context "c() and mother('request-httpx.c')"
snippet mother_perl_executable "Ausfuehren-Recht bei Perl-Skripten nicht geprueft"
Perl-Skripte sollen nur ausgefuehrt werden, wenn deren Eigentuemer das Ausfuehren-Recht hat. Das
muss hier noch mit stat(2) geprueft werden. (-1.0)
endsnippet

context "c() and mother('request-httpx.c')"
snippet mother_readdir_overwrite "d_name direkt verwendet, ohne Kopieren"
"The data returned by readdir() may be overwritten by subsequent calls to readdir() for the same
directory stream." (Manpage readdir(3)) Der Name muss dementsprechend kopiert werden, z.B. mittels
strdup(3). (-1.0)
endsnippet

context "c() and mother('request-httpx.c')"
snippet mother_readdir_r "readdir_r() verwendet"
readdir_r(3) ist laut Manpage deprecated (dt. veraltet) und sollte deswegen nicht verwendet werden.
readdir(3) muss zwar laut POSIX nicht thread-safe sein, aber "[...] in modern implementations
(including the glibc implementation), concurrent calls to readdir() that specify different
directory streams are thread-safe." (Manpage readdir(3)) Noch besser ist es, direkt scandir(3) zu
verwenden: das ist naemlich garantiert thread-safe (und macht das alles sowieso viel leichter ;)).
endsnippet

context "c() and mother('request-httpx.c')"
snippet mother_scandir "scandir() nicht verwendet"
Statt opendir(3) + readdir(3) sollte man lieber scandir(3) verwenden, da das den Code deutlich
simpler macht. ;)
endsnippet
# }}}
# }}}
